# 프록시

- 웹 프록시 서버는 중개자.
- 프록시는 클라이언트와 서버 사이에 위치하여 그들 사이의 `HTTP` 메세지를 정리하는 중개인처럼 동작.

## 웹 중개자

- 웹 프록시 서버는 클라이언트 입장에서 트랜잭션을 수행하는 중개인.
  - 웹 프록시가 없다면, 클라이언트는 `HTTP` 서버와 직접 이야기.
  - 웹 프록시가 있다면, 클라이언트는 자신의 입장에서 서버와 대화해주는 프록시와 이야기.
    > 프록시 서버가 제공하는 좋은 서비스를 이용하게 됨.
- `HTTP` 프록시 서버는 웹 서버이기도 하고 웹 클라이언트이기도 함.
- 프록시는 `HTTP` 클라이언트의 요청을 받게 되므로, 반드시 웹 서버처럼 요청과 커넥션을 적절히 다루고 응답을 돌려주어야 함.
- 동시에 프록시는 요청을 서버로 보내기도 하므로, 요청을 보내고 응답을 받는 올바른 `HTTP` 클라이언트처럼 동작해야 함.

> `HTTP` 프록시는 `HTTP` 클라이언트와 `HTTP` 서버 양쪽 규칙 모두를 주의 깊게 따라야 함.

### 개인 프록시와 공유 프록시

- 프록시 서버는 하나의 클라이언트가 독점적으로 사용할 수도 있고, 여러 클라이언트가 공유할 수도 있음.

#### 공용 프록시

- 여러 클라이언트가 함께 사용하는 프록시.
- 대부분의 프록시는 공용이며 공유된 프록시.
- 중앙 집중형 프록시를 관리하는 것이 비용 효율이 높고 쉬움.
- 캐시 프록시 서버와 같은 몇몇 프록시 애플리케이션은 프록시를 이용하는 사용자가 많을 수록 유리함.
  - 사용자들의 공통된 요청에서 이득을 취할 수 있기 때문.

#### 개인 프록시

- 하나의 클라이언트를 위한 프록시.
- 클라이언트 컴퓨터에서 직접 실행되는 형태로 꾸준히 사용됨.
- 브라우저의 보조 제품들은 몇몇 `ISP` 서비스와 마찬가지로 브라우저의 기능을 확장하거나 성능을 개선하거나 무료 `ISP` 서비스를 위한 광고를 운영하기 위해 작은 프록시를 사용자의 컴퓨터에서 직접 실행.

### 프록시 대 게이트웨이

- 프록시: 같은 프로토콜을 사용하는 둘 이상의 애플리케이션을 연결.
- 게이트웨이: 서로 다른 프로토콜을 사용하는 둘 이상의 애플리케이션을 연결.
  - 클라이언트와 서버가 서로 다른 프로토콜로 말하더라도 서로 간의 트랜잭션을 완료할 수 있도록 해주는 프로토콜 변환기처럼 작동.
- 실질적으로 프록시와 게이트웨이의 차이점은 모호.
  - 브라우저와 서버는 다른 버전의 `HTTP`를 구현하기 때문에, 프록시는 때때로 약간의 프로토콜 변환을 하기도 함.
- 상용 프록시 서버는 `SSL` 보안 프로토콜, `SOCKS` 방화벽, `FTP` 접근 그리고 웹 기반 애플리케이션을 지원하기 위해 게이트웨이 기능을 구현.

---

## 왜 프록시를 사용하는가?

- 프록시 서버는 보안 개선, 성능 증가, 비용 절약 등 실용적이고 유용한 일을 함.
- 프록시 서버는 모든 `HTTP` 트래픽을 들여다보고 건드릴 수 있기 때문에, 부가적인 가치를 주는 여러 유용한 웹 서비스를 구현하기 위해 트래픽을 감시하고 수정 가능.

#### 어린이 필터

- 교육 사이트를 제공하면서 성인 콘텐츠를 차단하는 필터링 프록시 사용 가능.
- 부적절한 사이트의 접근 강제로 거부.

#### 문서 접근 제어자

- 많은 웹 서버들과 웹 리소스에 대한 단일한 접근 제어 전략을 구현하고 감사 추적(audit trail)을 하기 위해 사용 가능.
- 각기 다른 조직에서 관리되는 다양한 종류의 수 많은 웹 서버들에 대한 접근 제어를 수시로 갱신할 필요 없이, 중앙 프록시 서버에서 접근 제어를 설정 가능.

#### 보안 방화벽

- 보안을 강화하기 위해 프록시 서버를 사용.
- 프록시 서버는 조직 안에 들어오거나 나가는 응용 레벨 프로토콜의 흐름을 네트워크의 한 지점에서 통제.
- 바이러스를 제거하는 웹이나 이메일 프록시가 사용할 수 있는, 트래픽을 세심히 살펴볼 수 있는 후크(`hook`)를 제공.

#### 웹 캐시

- 프록시 캐시는 인기 있는 문서의 로컬 사본을 관리하고 해당 문서에 대한 요청이 오면 빠르게 제공하여, 느리고 비싼 인터넷 커뮤니케이션을 줄임.

#### 대리 프록시

- 어떤 프록시들은 웹 서버인 것처럼 위장.
- 대리 혹은 리버스 프록시라고 불리는 이들은 진짜 웹 서버의 요청을 받지만, 웹 서버와는 달리 요청받은 콘텐츠의 위치를 찾아내기 위해 다른 서버와 커뮤니케이션을 시작.
- 공용 콘텐츠에 대한 느린 웹 서버의 성능을 개선하기 위해 사용 가능.
  - 이런 용도의 대리 프록시를 흔히 서버 가속기라고 부름.
- 콘텐츠 라우팅 기능과 결합되어 주문형 복제 콘텐츠의 분산 네트워크를 만들기 위해 사용 가능.

#### 콘텐츠 라우터

- 인터넷 트래픽 조건과 콘텐츠의 종류에 따라 요청을 특정 웹 서버로 유도하는 콘텐츠 라우터로 동작 가능.
- 콘텐츠 라우터는 또한 사용자들에게 제공할 여러 서비스를 구현하는데 사용 가능.
  - 높은 성능을 위한 돈을 지불했다면, 요청을 가까운 복제 캐시로 전달.
  - 필터링 서비스에 가입했다면, `HTTP` 요청이 필터링 프록시를 통과하도록 설정.
- 많은 흥미로운 서비스가 맞춤형 콘텐츠 라우팅 프록시를 이용해서 구성 가능.

#### 트랜스코더

- 콘텐츠를 클라이언트에게 전달하기 전에 본문 포맷을 수정 가능.
- 데이터의 표현 방식을 자연스럽게 변환하는 것을 "트랜스코딩"이라고 부름.
- 트랜스코딩 프록시는 자신을 거쳐가는 파일(`GIF` 이미지를 `JPG` 이미지로, 텍스트 파일을 압축하는 등)의 변환 및 수정 가능.
  - 문서를 외국어 문서로 변환하는 것 또한 가능.

#### 익명화 프록시(`Anonymizer`)

- `HTTP` 메세지에서 신원을 식별할 수 있는 특성들(클라이언트 `IP` 주소, `From` 헤더, `Referer` 헤더, 쿠키, `URI` 세션 아이디 등)을 적극적으로 제거함으로써 개인 정보 보호와 익명성 보장에 기여.
  - `User-Agent` 헤더에서 사용자의 컴퓨터와 `OS`의 종류를 제거.
  - 사용자의 이메일 주소를 보호하기 위해 `From` 헤더 제거.
  - 어떤 사이트를 거쳐서 방문했는지 알기 어렵게 하기 위해 `Referer` 헤더 제거.
  - 프로필과 신원 정보를 없애기 위해 `Cookie` 헤더 제거.

---

## 프록시는 어디에 있는가?

### 프록시 서버 배치

- 어떻게 사용할지에 따라서 프록시는 어디든 배치 가능.

#### 출구(`Egress`) 프록시

- 로컬 네트워크와 더 큰 인터넷 사이를 오가는 트래픽을 제어하기 위해 프록시를 로컬 네트워크 출구에 위치 가능.
- 방화벽 제공 및 인터넷 요금 절약과 트래픽 성능 개선 등의 이유를 위해 사용 가능.
  - 부적절한 콘텐츠를 브라우징하는 것을 막기 위해 필터링 출구 프록시 사용 가능.

#### 접근(입구) 프록시

- 모든 요청을 종합적으로 처리하기 위해 프록시는 `ISP` 접근 지점에 위치 가능.
- `ISP`는 사용자들의 다운로드 속도를 개선하고 인터넷 대역폭 비용을 줄이기 위해 캐시 프록시를 사용해 많이 찾는 문서들의 사본을 저장.

#### 대리 프록시(리버스 프록시)

- 네트워크의 가장 끝에 있는 웹 서버들의 바로 앞에 위치하여 웹 서버로 향하는 모든 요청을 처리하고 필요할 때만 웹 서버에 자원을 요청 가능.
- 웹 서버에 보안 기능을 추가하거나 빠른 웹 서버 캐시를 느린 웹 서버의 앞에 놓아 성능 개선 가능.
- 일반적으로 웹 서버의 이름과 `IP` 주소로 스스로를 가장하기 때문에, 모든 요청은 서버가 아닌 이 프록시로 가게 됨.

#### 네트워크 교환 프록시

- 캐시를 이용해 인터넷 교차로의 혼잡을 완화하고 트래픽 흐름을 감시하기 위해, 충분한 처리 능력을 갖춘 프록시가 네트워크 사이의 인터넷 피어링 교환 지점에 위치 가능.

### 프록시 계층

- 프록시들은 프록시 계층이라고 불리는 연쇄를 구성 가능.
- 프록시 계층에서, 메세지는 최종적으로 원 서버에 도착할 때까지 프록시와 프록시를 거쳐서 이동.
- 프록시 계층에서 프록시 서버들은 `부모-자식` 관계를 가짐.
  - 다음 번 인바운드 프록시(서버 가까운 쪽): 부모
  - 다음 번 아웃바운드 프록시(클라이언트 가까운 쪽): 자식

#### 프록시 계층 콘텐츠 라우팅

- 프록시 계층이 반드시 정적인 것은 아님.
- 프록시 서버는 여러 가지 판단 근거에 의해 메세지를 다양하고 유동적인 프록시 서버와 원 서버들의 집합에게 보낼 수 있음.
  - 요청된 객체가 콘텐츠 분산을 위해 돈을 지불한 웹 서버에 속한 경우, 프록시는 요청을 가까운 캐시 서버에게 보내 캐시된 객체를 반환하거나, 그럴 수 없을 때는 서버에서 가져오게 할 수 있음.
  - 요청이 특정 종류의 이미지에 대한 것인 경우, 접근 프록시는 그 요청을 특화된 압축 프록시에게 보내어 그 프록시가 이미지를 가져와 압축하게 하여 느린 모뎀으로 접속했더라도 빠르게 클라이언트가 다운로드할 수 있게 함.
- 동적 부모 선택의 예
  - 부하 균형
    - 자식 프록시는 부하를 분산하기 위해 현재 부모들의 작업량 수준에 근거하여 부모 프록시 선택 가능.
  - 지리적 인접성에 근거한 라우팅
    - 자식 프록시는 원 서버의 지역을 담당하는 부모를 선택 가능.
  - 프로토콜/타입 라우팅
    - 자식 프록시는 `URI`에 근거하여 다른 부모나 원 서버로 라우팅 가능.
    - 어떤 특정 종류의 `URI`를 갖고 있는 요청의 경우, 특별한 프록시로 보내져 특별한 프로토콜로 처리 가능.
  - 유료 서비스 가입자를 위한 라우팅
    - 웹 서비스 운영자가 빠른 서비스를 위해 추가금을 지불했다면, 그들의 `URI`는 대형 캐시나 성능 개선을 위한 압축 엔진으로 라우팅 가능.
- 동적 부모 라우팅 로직은 제품(설정 파일, 스크립트 언어, 동적으로 실행 가능한 플러그인 등)마다 다르게 구현.

### 어떻게 프록시가 트래픽을 처리하는가

- 클라이언트 트래픽이 프록시로 가도록 만드는 방법 네 가지
  1. 클라이언트를 수정한다
     - 많은 웹 클라이언트들은 수동 혹은 자동 프록시 설정을 지원.
     - 클라이언트가 프록시를 사용하도록 설정되어 있다면, 클라이언트는 `HTTP` 요청을 의도적으로 원 서버가 아닌 프록시로 보냄.
  2. 네트워크를 수정한다
     - 클라이언트는 알지도 못하고 간섭도 할 수 없는 상태에서, 네트워크 인프라를 가로채서 웹 트래픽을 프록시로 가도록 조정하는 몇 가지 기법을 보유.
     - 이 가로챔은 일반적으로 `HTTP` 트래픽을 지켜보고 가로채어 클라이언트 모르게 트래픽을 프록시로 보내는 스위칭 장치와 라우팅 장치를 필요로 함.
       > 인터셉트 프록시라고 부름.
  3. `DNS` 이름 공간을 수정한다
     - 웹 서버 앞에 위치하는 대리 프록시는 웹 서버의 이름과 `IP` 주소를 자신이 직접 사용.
       - 따라서 모든 요청은 서버 대신 대리 프록시로 전달.
     - `DNS` 이름 테이블을 수동으로 편집하거나 사용할 적절한 프록시나 서버를 계산해주는 특별한 동적 `DNS`를 이용해서 조정 가능.
     - 몇몇 설치본에서는 실제 서버의 `IP` 주소와 이름은 변경되고 대리 프록시에게는 이전 주소와 이름이 주어짐.
  4. 웹 서버를 수정한다
     - 몇몇 웹 서버는 `HTTP` 리다이렉션 명령(응답 코드 `305`)을 클라이언트에게 돌려줌으로써 클라이언트의 요청을 프록시로 리다이렉트 하도록 설정 가능.
     - 리다이렉트를 받는 즉시 클라이언트는 프록시와의 트랜잭션을 시작.

---

## 클라이언트 프록시 설정

- 브라우저에서 프록시를 설정하는 방법.
  - 수동 설정
    - 프록시를 사용하겠다고 명시적으로 설정.
  - 브라우저 기본 설정
    - 브라우저 벤더나 배포자는 소비자에게 전달하기 전에 프록시를 미리 설정 가능.
  - 프록시 자동 설정(Proxy auto-configuration, `PAC`)
    - `JavaScript` 프록시 자동 설정(`PAC`) 파일에 대한 `URI` 제공 가능.
    - 클라이언트는 어떤 프록시, 프록시 서버를 써야하는지 판단하기 위해 `JavaScript` 파일 로드 후 실행.
  - `WPAD` 프록시 발견
    - 대부분의 브라우저는 자동 설정 파일을 다운받을 수 있는 "설정 서버"를 자동으로 찾아주는 웹 프록시 자동 발견 프로토콜(`WPAD`, Web Proxy Autodiscovery Protocol)을 제공.

### 클라이언트 프록시 설정: 수동

- 많은 웹 클라이언트가 프록시를 수동으로 설정 가능.
- 프록시의 호스트와 포트를 지정함.
- 몇몇 `ISP`는 그들의 요구에 맞춰 미리 설정된 브라우저나 웹 트래픽을 프록시 서버로 리다이렉트 하는 맞춤형 운영체제를 구입.

> 단순하지만 유연하지 못함.  
> 모든 콘텐츠를 위해 단 하나의 프록시 서버만 지정 가능하며, 장애 시의 대체 작동에 대한 지원도 없음.  
> 큰 조직에서 관리 문제를 야기.

> 설정된 브라우저가 매우 많다면 그 모두를 원하는 대로 설정 변경하는 것은 어렵거나 불가능.

### 클라이언트 프록시 설정: `PAC` 파일

- 프록시 자동 설정(`PAC`) 파일은 프록시 설정에 대한 보다 동적인 해결책.
  - 프록시 설정을 그때그때 상황에 맞게 계산해주는 작은 `JavaScript` 프로그램이기 때문.
  - 문서에 접근할 때마다, `JavaScript` 함수가 적절한 프록시 서버를 선택.
- `PAC` 파일을 사용하려면, `JavaScript` `PAC` 파일의 `URI`를 브라우저에서 설정해야 함.
- 브라우저는 `URI`로부터 `PAC` 파일을 가져와서 매 접근마다 적절한 프록시 서버를 계산하기 위해 `JavaScript` 로직을 이용.
- `PAC` 파일은 일반적으로 `.pac` 확장자를 가지며 `MIME` 타입은 `application/x-ns-procy-autoconfig`임.
- 각 `PAC` 파일은 반드시 `URI`에 접근할 때 사용할 적절한 프록시 서버를 계산해주는 `FindProxyForUrl(url, host)`라는 함수를 정의해야 함.
  - `FindProxyForUrl` 함수의 반환 값.
    - `DIRECT`: 프록시 없이 연결이 직접 이루어져야 함.
    - `PROXY host:port`: 지정한 프록시를 사용.
    - `SOCKS host:port`: 지정한 `SOCKS` 서버를 사용.
- `PAC` 파일 예제
  ```js
  function FindProxyForURL(url, host) {
    if (url.substring(0, 5) === "http:") {
      return "PROXY http-proxy.mydomain.com:8080";
    } else if (url.substring(0, 4) === "ftp:") {
      return "PROXY ftp-proxy.mydomain.com:8080";
    } else {
      return "DIRECT";
    }
  }
  ```

### 클라이언트 프록시 설정: `WPAD`

- `WPAD`는 여러 발견 메커니즘들의 상승 전략을 이용해 브라우저에게 알맞은 `PAC` 파일을 자동으로 찾아주는 알고리즘.
- `WPAD` 프로토콜이 구현된 클라이언트의 일
  - `PAC URI`를 찾기 위해 `WPAD` 사용.
  - 주어진 `URI`에서 `PAC` 파일 가져옴.
  - 프록시 서버를 알아내기 위해 `PAC` 파일 실행.
  - 알아낸 프록시 서버를 이용해서 요청을 처리.
- 올바른 `PAC` 파일을 알아내기 위해 일련의 리소스 발견 기법 사용.
- `WPAD`는 성공할 때까지 각 기법을 하나씩 시도.
  - 동적 호스트 발견 규약(`DHCP`)
  - 서비스 위치 규약(`SLP`)
  - `DNS` 잘 알려진 호스트 명
  - `DNS` `SRV` 레코드
  - `DNS` `TXT` 레코드 안의 서비스 `URI`

---

## 프록시 요청의 미묘한 특징들

### 프록시 `URI`는 서버 `URI`와 다르다

- 웹 서버와 웹 프록시 메세지의 문법은 서로 같지만, 클라이언트가 프록시 대신 서버로 요청을 보내면 요청 `URI`는 달라짐.
- 클라이언트가 웹 서버로 요청을 보낼 때, 요청 줄은 스킴, 호스트, 포트 번호가 없는 부분 `URI`
  ```shell
  GET /index.html HTTP/1.0
  User-Agent: SuperBrowser v1.3
  ```
- 클라이언트가 프록시로 요청ㅇ르 보낼 때, 완전한 `URI`
  ```shell
  GET http://www.marys-antiques.com/index.html HTTP/1.0
  User-Agent: SuperBrowser v1.3
  ```
- 원래의 `HTTP` 설계에서, 클라이언트는 단일한 서버와 직접 대화.
  - 가상 호스팅은 존재하지 않았고, 프록시에 대한 대비도 없었음.
  - 단일 서버는 자신의 호스트 명과 포트 번호를 알고 있으므로, 클라이언트는 불필요한 정보 발송을 피하기 위해 스킴과 호스트, 포트 번호가 없는 부분 `URI` 보냄.
- 프록시가 부상하면서, 프록시는 목적지 서버와 커넥션을 맺어야 하기 때문에, 그 서버의 이름을 알 필요가 생김.
  - 프록시 기반 게이트웨이는 `FTP` 리소스나 그 외의 스킴과 연결하기 위해 `URI`의 스킴을 알 필요가 생김.
- 이에 서버로는 부분 `URI`, 프록시로는 완전한 `URI`를 보냄.
  - 클라이언트가 프록시를 사용하지 않도록 설정되어 있다면, 부분 `URI`
  - 클라이언트가 프록시를 사용하도록 설정되어 있다면, 완전한 `URI`

### 가상 호스팅에서 일어나는 같은 문제

- 프록시의 스킴, 호스트, 포트 번호 누락 문제는 가상으로 호스팅되는 웹 서버가 직면한 것과 같은 문제.
- 가상으로 호스팅되는 웹 서버는 여러 웹 사이트가 같은 물리적 웹 서버를 공유.
- 요청 하나가 부분 `URI`로 오면, 가상 호스팅 웹 서버는 요청이 접근하고자 하는 웹 사이트의 호스트 명을 알 필요가 생김.
- 해결책
  - 명시적인 프록시는 요청 메세지가 완전한 `URI`를 갖도록 함으로써 해결.
  - 가상 호스팅 웹 서버는 호스트와 포트에 대한 정보가 담겨있는 `Host` 헤더를 요구.

### 인터셉트 프록시는 부분 `URI`를 받는다

- 클라이언트가 올바르게 `HTTP`를 구현했다면, 명시적으로 설저된 프록시에게는 완전한 `URI`를 보냄.
- 하지만 클라이언트는 자신이 프록시와 대화하고 있음을 항상 알고 있는 것음 아님.
  - 몇몇 프록시는 클라이언트에게 보이지 않을 수 있기 때문.
- 클라이언트가 프록시를 사용한다고 설정되어 있지 않더라도, 클라이언트의 트래픽은 대리 프록시나 인터셉트 프록시를 지날 수 있음.
- 이 경우 모두, 클라이언트는 자신이 웹 서버와 대화하고 있다고 생각하고 완전한 `URI`를 보내지 않음.
  - 대리 프록시는 원 서버의 호스트 명과 `IP` 주소를 사용해 원 서버를 대신하는 프록시 서버.
  - 인터셉트 프록시는 네트워크 흐름에서 클라이언트에서 서버로 가는 트래픽을 가로채 캐시된 응답을 돌려주는 등의 일을 하는 프록시.
    - 클라이언트에서 서버로 가는 트래픽을 가로 채기 때문에, 웹 서버로 보내는 부분 `URI`를 얻게 됨.

### 프록시는 프록시 요청과 서버 요청을 모두 다룰 수 있다

- 트래픽이 프록시 서버로 리다이렉트 될 수 있는 여러 가지 방법이 존재하기 때문에, 다목적 프록시 서버는 요청 메세지의 완전한 `URI`와 부분 `URI`를 모두 지원해야 함.
- 프록시는 명시적인 프록시 요청에 대해서는 완전한 `URI`를 사용하고 아니면 부분 `URI`를 사용해야 하며, 웹 서버 요청의 경우에는 가상 `Host` 헤더를 사용해야 함.
- 완전한 `URI`와 부분 `URI`를 사용하는 규칙
  1. 완전한 `URI`가 주어졋다면, 프록시는 그것을 사용.
  2. 부분 `URI`가 주어졌고 `Host` 헤더가 없다면, 다음의 방법으로 원 서버 알아냄.
     - 프록시가 원 서버를 대신하는 대리 프록시라면, 프록시에 실제 서버의 주소와 포트 번호가 설정되어 있을 수 있음.
     - 이전에 어떤 인터셉트 프록시가 가로챘던 트래픽을 받았고, 그 인터셉트 프록시가 원 `IP` 주소와 포트 번호를 사용할 수 있도록 해두었다면, 그 `IP` 주소와 포트 번호를 사용.
     - 모두 실패했다면, 프록시는 원 서버를 알아낼 수 있는 충분한 정보를 갖고 있지 못한 것이므로 반드시 에러 메세지를 반환.

### 전송 중 `URI` 변경

- 프록시 서버는 요청 `URI`의 변경에 매우 신경을 써야 함.
  - 무해해 보이는 사소한 `URI` 변경이라도 다운스트림 서버와 상호운용성 문제 유발 가능.
- 몇몇 프록시는 `URI`를 다음 홉으로 보내기 전에 표준 형식으로 "정규화" 함.
  - `URI`에서 기본 `HTTP` 포트를 명시적인 `80` 포트로 변경하는 것.
  - 잘못 사용한 예악어를 올바르게 이스케이프하여 교체하는것.
- 일반적으로 프록시 서버는 가능한 관대하도록 애써야 함.
  - 프로토콜을 엄격하게 준수하도록 강제하는 "프로토콜 경찰"처럼 되면 안됨.
- 특히 `HTTP` 명세는 일반적인 인터셉트 프록시가 `URI`를 전달할 때 절대 경로를 고쳐 쓰는 것을 금지.
  - 유일한 예외는 빈 경로를 `/`로 교체하는 것.

### `URI` 클라이언트 자동 확장과 호스트 명 분석(`Hostname Resolution`)

- 브라우저는 프록시의 존재 여부에 따라 요청 `URI`를 다르게 분석.
  - 프록시가 없다면 사용자가 타이핑한 `URI`를 가지고 그에 대응하는 `IP` 주소를 찾음.
  - 만약 호스트 명이 발견되면 그에 대응하는 `IP` 주소들을 연결해 성공할 때까지 시도.
  - 호스트 명이 발견되지 않는다면, 사용자가 호스트 명의 짧은 약어를 타이핑한 것으로 보고 자동화된 호스트 명의 "확장"을 제공하고자 몇 가지 시도를 함.
    - 일반적인 웹 사이트 이름의 가운데 부분만 입력했다면 `www.` 접두사, `.com` 접미사를 붙임.
    - 해석할 수 없는 `URI`를 서드파티 사이트로 넘기기도 함.
      - 이 사이트는 오타 교정을 시도하고 사용자가 의도했을 `URI`를 제시.
    - 대부분의 시스템에서 `DNS`는 사용자가 호스트 명의 앞부분만 입력하면 자동을 도메인을 검색하도록 설정.

### 프록시 없는 `URI` 분석(`URI Resolution`)

- 브라우저는 유효한 호스트 명이 발견될 때까지 다양한 호스트 명의 가능성들을 검색.
- 명시적인 프록시가 존재하지 않는 경우, 부분 호스트 명을 자동으로 확장.

### 명시적인 프록시를 사용할 때의 `URI` 분석

- 명시적인 프록시를 사용한다면, 위의 확장을 더이상 수행할 수 없음.
  - 브라우저의 `URI`가 프록시를 그냥 지나쳐버리기 때문.
- 명시적인 프록시가 있는 경우, 부분 호스트 명을 자동 확장하지 않음.
- 이러한 이유로 몇몇 프록시는 `www.`, `.com` 자동 확장이나 지역 도메인 접미사 추가와 확장을 최대한 흉내내려고 시도.

### 인터셉트 프록시를 이용한 `URI` 분석

- 호스트 명 분석은 보이지 않는 인터셉트 프록시와 함께일 때 약간 달라짐.
  - 클라이언트 입장에서 프록시는 존재하지 않기 때문.
- `DNS`가 성공할 때까지 호스트 명을 자동 확장하는 브라우저를 사용할 때, 동작은 프록시가 아닌 서버의 경우와 별 차이가 없음.
- 그러나 서버로의 커넥션이 만들어졌을 때는 분명한 차이 발생.
- 인터셉트 프록시를 사용하고 있는 브라우저는 죽은 서버의 `IP` 주소 탐지 불가.

---

## 메세지 추적

- 프록시는 여러 벤더에 의해 개발됨.
  - 서로 다른 기능과 버그를 갖고 있으며, 여러 조직에 의해 관리.
- 서로 다른 스위치와 라우터를 넘나드는 `IP` 패킷의 흐름을 추적하는 것 못지 않게 프록시를 넘나드는 메세지의 흐름을 추적하고 문제점을 찾아내는 일도 필요.

### `Via` 헤더

- `Via` 헤더 필드는 메세지가 지나는 각 중간 노드(프록시나 게이트웨이)의 정보를 나열.
  - 메세지가 또 다른 노드를 지날 때마다, 중간 노드는 `Via` 목록의 끝에 만드시 추가되어야 함.
- `Via` 문자열 예시
  ```shell
  Via: 1.1 proxy-62.irenes-isp.net, 1.0 cache.joes-hardware.com
  ```
  - 두 개의 프록시를 지남.
  - 첫 번째 프록시는 `HTTP/1.1`을 구현, `proxy-62.irenes-isp.net`으로 불림.
  - 두 번째 프록시는 `HTTP/1.0`을 구현, `cache.joes-hardware.com`으로 불림.
- `Via` 헤더 필드는 메세지의 전달을 추적하고, 메세지 루프를 진단하고, 요청을 보내고 그에 대한 응답을 돌려주는 과정에 관여하는 모든 메세지 발송자들의 프로토콜을 다루는 능력을 알아보기 위해 사용.
- 프록시는 또한 네트워크 라우팅 루프를 탐지하기 위해 `Via` 헤더 사용 가능.
  - 프록시는 요청을 보내기 전에 자신을 가리키는 유일한(`unique`) 문자열을 `Via` 헤더에 삽입해야 하며 네트워크에 라우팅 루프가 있는지 탐지하기 위해 이 문자열이 들어온 요청에 있는지 검사.

#### `Via` 문법

- `Via` 헤더 필드는 쉼표로 구분된 경유지(`waypoint`)의 목록.
- 각 경유지는 개별 프록시 서버나 게이트웨이 홉을 나타내며 그들 중간 노드의 프로토콜과 주소에 대한 정보를 담고 있음.
- `Via` 헤더 형식 구문
  ```shell
  Via               = "Via" ":" (waypoint) [", " ( waypoint )...]
  waypoint          = ( received-protocol received-by [ comment ] )
  received-protocol = [ protocol-name "/" ] protocol-version
  received-by       = ( host [ ":" port ] ) | pseudonym
  ```
  - 각 `Via waypoint`는 프로토콜 이름(선택, 기본은 `HTTP`), 프로토콜 버전(필수), 노드 이름(필수), 코멘트(선택)의 최대 4개의 구성 요소를 담을 수 있음.

#### 프로토콜 이름

- 중개자가 받은 프로토콜.
- 프로토콜 이름은 버전 앞에 `/`로 구분되어 붙음.
- 비 `HTTP` 프로토콜은 게이트웨이가 다른 프로토콜(`HTTPS`, `FTP` 등)을 위해 `HTTP` 요청에 접속할 때 발생할 수 있음.

#### 프로토콜 버전

- 수신한 메세지의 버전.
- 버전의 포맷은 프로토콜에 달림.
  - `HTTP`의 경우, 표준 버전 번호(`1.0`, `1.1` 등)가 사용.
- 버전은 `Via` 필드에 포함되므로, 애플리케이션들은 자신 이전의 모든 중개자들이 어떤 버전을 다룰 수 있는지 알 수 있음.

#### 노드 이름

- 중개자의 호스트와 포트 번호(선택, 포트가 포함되어 있지 않다면 사용하는 프로토콜의 기본 포트로 간주).
- 몇몇 조직은 정보 보호를 이유로 진짜 호스트 명을 밝히고 싶지 않아 가명으로 대체.

#### 노드 코멘트

- 중개자 노드를 서술하는 선택적인 코멘트.
- 벤더나 버전 정보를 여기 포함시킴.
- 몇몇 프록시 서버는 장치에서 일어난 이벤트에 대한 진단 정보를 포함하는 데도 코멘트 필드 사용.

#### `Via` 요청과 응답 경로

- 요청 메세지와 응답 메세지 모두 프록시를 지나므로 둘 모두 `Via` 헤더를 가짐.
- 요청과 응답은 보통 같은 `TCP` 커넥션을 오가므로, 응답 메세지는 요청과 같은 경로로 되돌아 감.
- 응답의 `Via` 헤더는 거의 언제나 요청의 `Via` 헤더와 반대.

#### `Via`와 게이트웨이

- 몇몇 프록시는 서버에게 비 `HTTP` 프로토콜을 사용할 수 있는 게이트웨이 기능 제공.
- `Via` 헤더는 이러한 프로토콜 변환을 기록하므로 `HTTP` 애플리케이션은 프록시 연쇄에서 프로토콜 능력과 변환이 있었는지 감지 가능.
  - `HTTP` 요청을 받은 프로토콜 게이트웨이로 동작하는 프록시는 `FTP` 요청을 이용해 `FTP` 서버로부터 원하는 객체를 받아옴.
  - 프로토콜 게이트웨이로 동작하는 프록시는 그 객체를 `Via` 헤더 필드와 함께 클라이언트에게 `HTTP` 응답으로 되돌려 줌.
    ```shell
    Via: FTP/1.0 proxy.irenes-isp.net (Traffic-Server/5.0.1-17882 [cMs f ])
    ```
  - 수신 프로토콜이 `FTP`.
  - 선택적인 코멘트는 프록시 서버의 브랜드, 버전 번호, 몇 가지 벤더 진단 정보를 포함.

#### `Server` 헤더와 `Via` 헤더

- `Server` 응답 헤더 필드는 원 서버에 의해 사용되는 소프트웨어를 알려줌.
  ```shell
  Server: Apache/1.3.14 (Unix) PHP/4.0.4
  Server: Netscape-Enterprise4.1
  Server: Microsoft-IIS/5.0
  ```
- 응답 메세지가 프록시를 통과할 때, 프록시는 `Server` 헤더를 수정해서는 안됨.
- `Server` 헤더는 원 서버를 위해서 존재.
  - 프록시는 `Via` 항목을 추가.

#### `Via`가 개인정보 보호와 보안에 미치는 영향

- `Via` 문자열 안에 정확한 호스트 명이 들어가기를 원하지 않는 경우가 있을 수 있음.
- 보통 명시적으로 이 동작이 켜져 있지 않은 이상, 프록시 서버가 네트워크 방화벽의 일부인 경우 프록시는 방화벽 뒤에 숨어있는 호스트의 이름과 포트를 전달해서는 안됨.
  - 방화벽 뒤의 네트워크 아키텍처에 대한 정보가 악의적인 집단에 의해서 이요될 수 있기 때문.
- `Via` 노드 이름 전달이 가능하지 않다면, 보안 경계선의 일부분인 프록시는 호스트 명을 그 호스트에 적당한 가명으로 교체.
  - 이렇게 실제 이름을 알기 어렵게 되었다고 하더라도, 일반적으로 프록시는 각 프록시 서버에 대한 `Via` 경유지 항목을 유지하려 노력해야 함.
- 내부 네트워크 아키텍처의 설계와 토폴로지를 알아내기 어렵게 하기 위한 아주 강력한 보안 요구사항을 갖고 있는 조직들을 위해, 프록시는 정렬된 일련의 `Via` 경유지 항목들(수신 프로토콜 값들이 동일한)을 하나로 합칠 수 있음.
  ```shell
  Via: 1.0 foo, 1.1 devirus.company.com, 1.1 access-logger.company.com
  ```
  ```shell
  Via: 1.0 foo, 1.1 concealed-stuff
  ```
  - 여러 경유지들이 모두 같은 조직의 통제 하에 있고 호스트가 이미 가명으로 교체되어 있지 않은 이상 그들에 대한 항목을 합쳐서는 안됨.
  - 수신된 네트워크 프로토콜 값이 서로 다른 항목들도 합쳐서는 안됨.

### `TRACE` 메서드

- 프록시 서버는 메세지가 전달될 때 메세지를 바꿀 수 있음.
  - 헤더가 추가, 변경, 삭제되거나 본문이 다른 형식으로 변환 가능.
- 프록시가 점점 복잡해지면서, 상호운용성 문제가 증가.
- 프록시 네트워크를 쉽게 진단하기 위해, `HTTP` 프록시 네트워크를 통해 홉에서 홉으로 전달될 때마다 메세지의 내용이 어떻게 변하는지 편리하게 관찰할 방법이 필요.
- `HTTP/1.1`의 `TRACE` 메서드는 요청 메세지를 프록시의 연쇄를 따라가면서 어떤 프록시를 지나가고 어떻게 각 프록시가 요청 메세지를 수정하는지 관찰/추적 가능.
  - `TRACE`는 프록시의 흐름을 디버깅하는데 매우 유용.
  - 널리 구현되어 있지 않은 단점.
- `TRACE` 요청이 목적지 서버에 도착했을 때, 서버는 전체 요청 메세지를 `HTTP` 응답 메세지의 본문에 포함시켜 송신자에게 그대로 돌려 보냄.
- `TRACE` 응답이 도착했을 때, 클라이언트는 서버가 받은 메세지와 그 메세지가 지나간 프록시들의 목록(`Via` 헤더)를 검사.
  - `TRACE` 응답의 `Content-Type`응 `message/http`이며 상태는 `200 OK`.

#### `Max-Forwards`

- 일반적으로 `TRACE` 메세지는 중간에 프록시들이 몇 개나 있든 신경 쓰지 않고 목적지 서버로의 모든 경로를 여행.
- `TRACE`와 `OPTIONS` 요청의 프록시 홉(`hop`) 개수를 제한하기 위해 `Max-Forwards` 사용 가능.
  - 이는 전달되는 메세지가 무한 루프에 빠지지 않는지 프록시 연쇄를 테스트하거나 연쇄 중간의 특정 프록시 서버들의 효과를 체크할 때 유용.
- `Max-Forwards`는 또한 `OPTIONS` 메세지의 전달 횟수도 제한.
- `Max-Forwards` 요청 헤더 필드는 이 요청 메세지가 몇 번 더 다음 홉으로 전달될 수 있는지 말해주는 정수 하나를 담고 있음.
  - 만약 이 값이 `0`(`Max-Forwards: 0`)이라면, 수신자는 자신이 원 서버가 아니라 할지라도 `TRACE` 메세지를 더이상 전달하지 말고 반드시 클라이언트에게 돌려줘야 함.
  - 받은 `Max-Forwards` 값이 `0`이상이라면, 전달될 메세지의 `Max-Forwards` 필드는 반드시 `1` 감소된 값으로 갱신.
- 모든 프록시와 게이트웨이는 `Max-Forwards`를 지원해야 함.
- 프록시 연쇄의 어떤 특정 홉에서의 요청을 보기 위해 `Max-Forwards` 사용 가능.

---

## 프록시 인증

- 프록시는 접근 제어 장치로서 제공 가능.
- `HTTP`는 단순한 유효한 접근 권한 자격을 프록시에 제출하지 않는 한 콘텐츠에 대한 요청을 차단하는 프록시 인증이라는 메커니즘을 정의.
  - 제한된 콘텐츠에 대한 요청에 프록시 서버에 도착했을 때, 프록시 서버는 접근 자격을 요구하는 `407` Proxy Authorization Required 상태 코드를 어떻게 그러한 자격을 제출할 수 있는지 설명해주는 `Proxy-Authenticate` 헤더 필드와 함께 반환 가능.
  - 클라이언트는 `407` 응답을 받게 되면, 로컬 데이터베이스를 확인해서든 사용자에게 물어봐서든 요구되는 자격을 수집.
  - 자격을 획득하면, 클라이언트는 요구되는 자격을 `Proxy-Authorization` 헤더 필드에 담아서 요청을 다시 보냄.
  - 자격이 유효하다면, 프록시는 원 요청을 연쇄를 따라 통과시킴.
  - 자격이 유효하지 않다면, `407` 응답을 반환.
- 프록시 인증은 인증에 참여하는 프록시가 프록시 연쇄 상에 여러 개 있을 때는 일반적으로 잘 동작하지 않음.
  - 프록시 연쇄의 특정 경유지와 인증 자격을 서로 짝지어주는 `HTTP`의 기능 확장을 제안했지만, 널리 구현되지는 않음.

---

## 프록시 상호운용성

- 프록시 서버는 서로 다른 프로토콜을 구현했을 수도 있고, 이상한 동작을 할 수도 있는 클라이언트와 서버 사이를 중개해야 함.

### 지원하지 않는 헤더와 메서드 다루기

- 프록시 서버는 넘어오는 헤더 필드들을 모두 이해하지 못할 수도 있음.
  - 새로운 헤더, 특정 애플리케이션만을 위한 헤더 등.
- 프록시는 이해할 수 없는 헤더 필드는 반드시 그대로 전달해야 하며, 같은 이름의 헤더 필드가 여러 개 있는 경우에는 그들의 상대적인 순서도 반드시 유지해야 함.
- 만약 프록시가 어떤 메서드와 친숙하지 않다면, 가능한 한 그 메세지를 다음 홉으로 전달하려 시도해야 함.
- 지원하지 않는 메서드를 통과시킬 수 없는 프록시는 오늘날 대부분의 네트워크에서 살아남지 못함.
  - `HTTP/1.1`은 메서드를 확장하는 것을 허용하고 있음.

### `OPTIONS`: 어떤 기능을 지원하는지 알아보기

- `HTTP` `OPTIONS` 메서드는 서버나 웹 서버의 특정 리소스가 어떤 기능을 지원하는지 클라이언트가 알아볼 수 있게 해줌.
- 서로 다른 기능 수준의 서버와 프록시가 더 쉽게 상호 작용할 수 있도록 클라이언트는 `OPTIONS`을 이용해 서버의 능력을 먼저 알아낼 수 있음.
- `OPTIONS` 요청의 `URI`가 별표(`*`)라면, 요청은 서버 전체의 능력에 대해 물음.
  ```shell
  OPTIONS * HTTP/1.1
  ```
- `OPTIONS` 요청의 `URI`가 실제 리소스라면, 특정 리소스에 대해 가능한 기능을 물음.
  ```shell
  OPTION http://www.joes-hardware.com/index.html HTTP/1.1
  static HTML file wouldn\'t accept a POST method.
  ```
- 성공한다면, `OPTIONS` 메서드는 서버에서 지원하거나 지정한 리소스에 대해 가능한 선택적인 기능들을 서술하는 여러 헤더 필드를 포함한 `200 OK` 응답을 반환.
  - `HTTP/1.1`이 명시한 헤더는 서버에 의해(또는 서버의 특정 리소스에 대해) 어떤 메서드가 지원되는지 서술하는 `Allow` 헤더 하나 뿐.
- 더 많은 정보를 위해 `OPTIONS`는 선택적인 응답 본문을 허용하지만 정의되지는 않음.

### `Allow` 헤더

- `Allow` 엔터티 헤더 필드는, 요청 `URI`에 의해 식별되는 자원에 대해 지원되는 메서드들이나 서버가 지원하는 모든 메서드(요청 `URI`가 `*`인 경우)를 열거.
  ```shell
  Allow: GET, HEAD, PUT
  ```
- `Allow` 헤더는 새 리소스가 지원했으면 하는 메서드를 추천하기 위해 요청 헤더로 사용 가능.
  - 서버는 추천 받은 메서드들을 모두 지원해야 할 의무는 없음.
  - 그 요청에 대한 응답에는 실제로 지원하는 메서드들을 열거하는 `Allow` 헤더를 포함시켜야 함.
- 프록시가 지정된 모든 메서드들을 이해할 수 없다고 해도, 프록시는 `Allow` 헤더 필드를 수정할 수 없다.
  - 클라이언트는 원 서버와 대화하는 다른 경로를 갖고 있을 수도 있기 때문.
