# 커넥션 관리

## `TCP` 커넥션

- `HTTP` 통신은 패킷 교환 네트워크 프로토콜들의 계층화된 집합인 `TCP/IP`를 통해 이루어짐.
- `TCP/IP` 커넥션이 맺어지면 클라이언트와 서버 컴퓨터 간에 주고받는 메세지들은 손실 혹은 손상되거나 순서가 바뀌지 않고 안전하게 전달.
- `TCP` 커넥션 예시
  1. 브라우저에서 호스트 명 추출.
  2. 호스트 명에 대한 `IP` 주소 찾음.
  3. 브라우저가 포트 번호(`80`)을 얻음.
  4. 브라우저가 `IP:포트`로 `TCP` 커넥션 생성.
  5. 브라우저가 서버로 `HTTP` `GET` 요청 메세지 전송.
  6. 브라우저가 서버에서 온 `HTTP` 응답 메세지를 읽음.
  7. 커넥션 종료.

### 신뢰할 수 있는 데이터 전송 통로인 `TCP`

- `HTTP` 커넥션은 대부분 `TCP` 커넥션으로, `TCP` 커넥션 한 쪽에 있는 바이트들은 반대쪽으로 순서에 맞게 정확히 전달되는 신뢰할 만한 통신 방식을 제공.

### `TCP` 스트림은 세그먼트로 나뉘어 `IP` 패킷을 통해 전송된다

- `TCP`는 `IP` 패킷(`IP` 데이터 그램)이라는 작은 조각을 통해 데이터를 전송.
- `HTTP`는 프로토콜 스택에서 최상위 계층.

  |          `HTTP`           |          `HTTPS`          |
  | :-----------------------: | :-----------------------: |
  |                           | `HTTP`(애플리케이션 계층) |
  | `HTTP`(애플리케이션 계층) | `TLS` or `SSL`(보안 계층) |
  |           `TCP`           |           `TCP`           |
  |           `IP`            |           `IP`            |
  |    Network Interfaces     |    Network Interfaces     |

  - `HTTP`에 보안 기능을 더한 `HTTPS`는 `TLS` 혹은 `SSL`이라 불리는 암호화, 보안 계층이 포함.

- `HTTP`는 현재 연결되어 있는 `TCP` 커넥션을 통해서 메세지 데이터 스트림을 세그먼트라는 단위로 나누고, 세그먼트를 `IP` 패킷이라고 불리는 봉투에 담아서 전달.

  - `IP` 패킷 내용
    1. `IP` 패킷 헤더(보통 `20Byte`)
       - 발신지와 목적지 `IP` 주소, 크기, 기타 플래그
    2. `TCP` 세그먼트 헤더(보통 `20Byte`)
       - `TCP` 포트 번호, `TCP` 제어 플래그, 데이터의 순서와 무결성을 검사하기 위한 숫자 값
    3. `TCP` 데이터 조각(0 혹은 그 이상의 바이트)

### `TCP` 커넥션 유지하기

- `TCP`는 포트 번호를 이용해서 여러 개의 커넥션을 유지.

  - 커넥션 구성 요소

  ```
  <발신지 IP 주소, 발신지 포트, 수신지 IP 주소, 수신지 포트>
  ```

  > 네 가지 커넥션 구성 요소를 모두 똑같이 가리키고 있는 커넥션은 있을 수 없음.

### `TCP` 소켓 프로그래밍

- 운영체제는 `TCP` 커넥션의 생성과 관련된 여러 기능 제공.
- 이 중 소켓 `API`는 `UNIX` 운영체제 용으로 먼저 개발.
- 소켓 `API`를 사용하면 `TCP` 종단(`endpoint`) 데이터 구조를 생성하고, 원격 서버의 `TCP` 종단에 그 종단 데이터 구조를 연결하여 데이터 스트림을 읽고 쓸 수 있음.
- `TCP API`는 기본적인 네트워크 프로토콜의 핸드셰이킹, 그리고 `TCP` 데이터 스트림과 `IP` 패킷 간의 분할 및 재조립에 대한 모든 세부사항을 외부로부터 숨김.

---

## `TCP`의 성능에 대한 고려

- `HTTP` 트랜잭션의 성능은 그 아래 계층인 `TCP` 성능에 영향을 받음.

### `HTTP` 트랜잭션 지연

- 트랜잭션을 처리하는 시간은 `TCP` 커넥션을 설정하고, 요청을 전송하고, 응답 메세지를 보내는 것에 비하면 상당히 짧음.

> 대부분의 `HTTP` 지연은 `TCP` 네트워크 지연 때문에 발생.

- `HTTP` 트랜잭션 지연의 원인
  1. `DNS resolution` 인프라
  2. `TCP` 커넥션 설정 시간(동시에 여러 개)
  3. 웹 서버의 데이터 요청 확인 및 처리 시간
  4. 응답 시간
- 이외에도 하드웨어의 성능, 네트워크와 서버의 전송 속도, 요청과 응답 메세지의 크기, 클라이언트와 서버 간의 거리에 따라 다름.
- `TCP` 프로토콜의 기술적인 복잡성도 지연에 큰 영향.

### 성능 관련 중요 요소

- `TCP` 커넥션의 핸드셰이크 설정
- 인터넷의 혼잡을 제어하기 위한 `TCP`의 느린 시작(`slow start`)
- 데이터를 한데 모아 한 번에 전송하기 위한 네이글(`Nagle`) 알고리즘
- `TCP`의 편승(`piggyback`) 확인응답(`acknowledgment`)을 위한 확인응답 지연 알고리즘
- `TIME_WAIT` 지연과 포트 고갈

### `TCP` 커넥션 핸드셰이크 지연

- 새로운 `TCP` 커넥션을 열 때, `TCP` 소프트웨어는 커넥션을 맺기 위한 조건을 맞추기 위해 연속으로 `IP` 패킷 교환.
- 작은 크기의 데이터 전송에 커넥션이 사용된다면 `HTTP` 성능 저하 유발.
- 크기가 작은 `HTTP` 트랜잭션은 `50%` 이상의 시간을 `TCP`를 구성하는데 사용.

> 구성으로 인한 지연을 제거하기 위해 `HTTP`가 이미 존재하는 커넥션을 재활용 가능.

### 확인응답 지연

- 인터넷 자체가 패킷 전송을 완벽히 보장하지 않기 때문에, `TCP`는 성공적인 데이터 전송을 보장하기 위해서 자체적인 확인 체계를 가짐.
- 각 `TCP` 세그먼트는 순번과 데이터 무결성 체크섬을 가짐.
- 각 세그먼트의 수신자는 세그먼트를 온전히 받으면 작은 확인응답 패킷을 송신자에게 반환.
  - 확인응답은 그 크기가 작기 때문에, `TCP`는 같은 방향으로 송출되는 데이터 패킷에 확인응답을 편승(`piggyback`) 시킴.
  - `TCP`는 송출 데이터 패킷과 확인응답을 하나로 묶어 네트워크를 좀 더 효율적으로 사용.
  - 같은 방향으로 가는 데이터 패킷에 편승되는 경우를 늘리기 위해 많은 `TCP` 스택은 "확인응답 지연" 알고리즘을 구현.

> 하지만 요청과 응답 두 가지 형식으로만 이루어지는 `HTTP` 동작 방식은, 데이터 패킷 편승 기회를 감소시키고 막상 "확인응답 지연 알고리즘"으로 인한 지연이 발생하여 기능을 수정하거나 비활성화할 수 있음.

### `TCP` 느린 시작(`slow start`)

- `TCP`의 데이터 전송 속도는 시간에 따라 자체적으로 '튜닝'되어 조율함.
  - 이를 "`TCP` 느린 시작"이라고 함.
  - 인터넷의 급작스러운 부하와 혼잡을 방지하는 데 사용.
- `TCP` 느린 시작은 `TCP`가 한 번에 전송할 수 잇는 패킷의 수를 제한.
- 이 혼잡제어 기능 때문에, 새로운 커넥션은 이미 있는 커넥션보다 느림.

> 따라서 이미 존재하는 커넥션을 재사용하는 기능이 있음.

### 네이글(`Nagle`) 알고리즘과 `TCP_NODELAY`

- 애플리케이션이 어떤 크기의 데이터라도 `TCP` 스택으로 전송할 수 있도록 `TCP`는 데이터 스트림 인터페이스를 제공.
- "네이글 알고리즘"은 네트워크의 효율을 위해서 패킷을 전송하기 전에 많은 양의 `TCP` 데이터를 한 개의 덩어리로 합침.
  - 작은 `HTTP` 메세지는 패킷을 채우지 못하기 때문에 지연.
  - 확인응답 지연과 함께 쓰일 경우 형편없는 동작.

> 성능 향상을 위해서 `HTTP` 스택에 `TCP_NODELAY` 파라미터 값을 설정하여 "네이글 알고리즘"을 비활성화 하기도 함.

## `TIME_WAIT`의 누적과 포트 고갈

- `TIME_WAIT` 포트 고갈은 성능 측정 시에 심각한 성능 저하를 발생시키지만, 보통 실제 상황에서는 문제를 발생시키지 않음.(측정 시에는 `IP` 주소의 개수를 제한하고, 부하를 발생시킬 컴퓨터의 수는 적기 때문)
- `TCP` 커넥션의 종단에서 `TCP` 커넥션을 끊으면, 종단에서는 커넥션의 `IP` 주소와 포트 번호를 메모리의 작은 제어 영역에 기록.
- 이 정보를 통해 이전 커넥션과 관련된 패킷이 그 커넥션과 같은 주소와 포트 번호를 가지는 새로운 커넥션에 삽입되는 문제를 방지.
- 커넥션을 너무 많이 맺거나 대기 상태로 있는 제어 블록인 너무 많아지게 되면 느려질 수 있음.

---

## `HTTP` 커넥션 관리

### 흔히 잘못 이해하는 `Connection` 헤더

- `HTTP` 메세지는 클라이언트에서 서버(혹은 리버스 서버)까지 중개 서버들을 하나하나 거치면서 전달.
- `HTTP Connection` 헤더 필드는 커넥션 토큰을 쉼표로 구분하여 가지고 있음.
- `Connection` 헤더에 전달될 수 있는 토큰의 종류
  1. `HTTP` 헤더 필드명은, 이 커넥션에만 해당되는 헤더들을 나열.
     - 다음 커넥션에 전달하면 안됨.
  2. 임시적인 토큰 값은, 커넥션에 대한 비표준 옵션을 의미.
  3. `close` 값은, 커넥션이 작업이 완료되면 종료되어야 함을 의미.
- `Connection` 헤더에는 홉별(`hop-by-hop`) 헤더 명을 기술.

### 순차적인 트랜잭션 처리에 의한 지연

- 순차적인 처리로 인한 지연에는 물리적인 지연 뿐만 아니라, 심리적인 지연도 존재.
  - 사용자는 여러 개의 이미지가 동시에 로드되는 것을 더 좋아함.
- 순차적으로 로드하는 방식의 단점은, 특정 브라우저의 경우 객체를 화면에 배치하려면 객체의 크기를 알아야 하기 떄문에 모든 객체를 내려받기 전까지 텅 빈 화면을 보여주는 것.

---

## 병렬(parallel) 커넥션

> 여러 개의 `TCP` 커넥션을 통한 동시 `HTTP` 요청

### 병렬 커넥션은 페이지를 더 빠르게 내려받는다

- 하나의 커넥션으로 객체들을 로드할 때의 대역폭 제한과 대기 시간을 줄일 수 있다면 더 빠르게 로드할 수 있음.
- 각 커넥션의 지연 시간을 겹치게 하면 총 지연 시간을 줄일 수 있고, 클라이언트의 인터넷 대역폴을 한 개의 커넥션이 다 써버리는 것이 아니라면 나머지 객체들을 내려받는 데에 남은 대역폭을 사용할 수 있음.

### 병렬 커넥션이 항상 더 빠르지는 않다

- 일반적으로 더 빠르기는 하지만, 클라이언트의 네트워크 대역폭이 좁을 때, 성능 상의 장점은 거의 없어짐.
- 또한 다수의 커넥션은 메모리를 많이 소모하고 자체적인 성능 문제 야기.
- 수백개의 커넥션으로 인해 서버, 고부하 프록시의 과부하로 성능 저하가 발생할 수 있음.

> 브라우저는 실제로 적은 수의 병렬 커넥션만을 허용.  
> 서버는 특정 클라이언트로부터 과도한 수의 커넥션이 맺어졌을 경우, 임의로 끊을 수 있음.

### 병렬 커넥션은 더 빠르게 '느껴질 수' 있다

- 여러 객체가 동시에 보이면서 사용자는 더 빠르게 내려받고 있는 것처럼 느낄 수 있음.

> 총 다운로드 시간과 무관하게 전체에 여러 작업이 일어나는 것을 확인하면 더 빠르다고 여김.

### 병렬 커넥션의 단점

- 각 트랜잭션마다 새로운 커넥션을 맺고 끊기 때문에 시간과 대역폭이 소모.
- 각각의 새로운 커넥션은 `TCP`의 느린 시작 때문에 성능이 떨어짐.
- 실제로 연결할 수 있는 병렬 커넥션의 수에는 제한이 있음.

---

## 지속(persistent) 커넥션

> 커넥션을 맺고 끊는 데서 발생하는 지연을 제거하기 위한 `TCP` 커넥션의 재활용

- 웹 클라이언트는 보통 같은 사이트 내에서 여러 개의 커넥션을 맺는데, 보통 같은 사이트를 가리킴. 이를 사이트의 지역성(`site locality`)라고 함.
- 처리가 완료된 후에도 `TCP` 커넥션을 유지하여 앞으로 있을 `HTTP` 요청에 재사용할 수 있는데, 이러한 `TCP` 커넥션의 유지를 지속 커넥션이라고 함.
- 지속 커넥션은 클라이언트나 서버가 커넥션을 끊기 전까지는 트랜잭션 간에도 커넥션을 유지.

### 지속 커넥션 vs 병렬 커넥션

- 지속 커넥션의 장점
  - 커넥션을 맺기 위한 사전 작업과 지연을 줄여줌.
  - 튜닝된 커넥션 유지.
  - 커넥션의 수를 줄임.
- 지속 커넥션의 위험성
  - 계속 연결된 상태로 수많은 커넥션이 쌓일 가능성.
    > 로컬의 리소스, 원격의 클라이언트와 서버의 리소스에 불필요한 소모.
- 지속 커넥션은 병렬 커넥션과 함께 사용될 때 가장 효과적.

### `HTTP/1.0+`의 `Keep-Alive` 커넥션

- `HTTP/1.0` 브라우저와 서버들은 일찍부터 다소 실험적이었던 `Keep-Alive` 커넥션을 지원하기 위해 확장.
- 설계 상의 문제는 `HTTP/1.1`에서 수정.

### `Keep-Alive` 동작

- `Keep-Alive`는 사용하지 않기로 결정되어 `HTTP/1.1` 명세에서 빠졌으나, 아직도 `Keep-Alive` 핸드셰이크가 널리 사용되고 있기 때문에 `HTTP` 애플리케이션은 그것을 처리할 수 있게 개발해야 함.
- `Keep-Alive` 커넥션을 구현한 클라이언트는 요청에 `Connection:Keep-Alive` 헤더를 포함.
- 응답에 `Connection:Keep-Alive` 헤더가 없으면 서버가 `Keep-Alive`를 지원하지 않을 것이라 추정.

### `Keep-Alive` 옵션

- `Keep-Alive` 헤더는 커넥션을 유지하기를 바라는 요청.
  - 무조건 따를 필요가 없으며, 언제든지 현재의 `Keep-Alive`를 끊을 수 있음.
  - 처리되는 트랜잭션의 수를 제한할 수도 있음.
- `Keep-Alive`의 동작은 `Keep-Alive` 헤더의 쉼표로 구분된 옵션들로 제어.
  1. `timeout` 파라미터는 커넥션이 얼마간 유지될 것인지 의미.
  2. `max` 파라미터는 커넥션이 몇 개의 `HTTP` 트랜잭션을 처리할 때까지 유지될 것인지 의미.
  3. `Keep-Alive` 헤더는 진단이나 디버깅을 주목적으로 하는, 처리되지는 않는 임의의 속성들을 지원하기도 함.
- 서버가 5개의 추가 트랜잭션이 처리될 동안 커넥션을 유지하거나, 2분 동안 커넥션을 유지하라는 내용

  ```
  Connection: Keep-Alive
  Keep-Alive: max=5, timeout=120
  ```

### `Keep-Alive` 커넥션 제한과 규칙

1. `HTTP/1.0`에서 `Keep-Alive`가 기본으로 지원되지 않아 사용하려면 `Connection: Keep-Alive` 요청 헤더를 보내야 함.
2. 커넥션을 계속 유지하려면 모든 메세지에 `Connection: Keep-Alive` 헤더를 포함해 보내야 함.

   - 클라이언트가 헤더를 보내지 않으면 서버는 요청을 처리한 후 커넥션을 끊음.

3. 클라이언트는 `Connection: Keep-Alive` 응답 헤더가 없는 것을 보고 서버가 응답 후에 커넥션을 끊을 것임을 알 수 있음.
4. 커넥션이 끊어지기 전에 엔터티 본문의 길이를 알 수 있어야 커넥션을 유지할 수 있음.

   - 엔터티 본문이 정확한 `Content-Length` 값과 함께 멀티파트 미디어 형식(multipart media type)을 가지거나 청크 전송 인코딩(chunked transfer encoding)으로 인코드 되어야 함을 뜻함.
   - 잘못된 `Content-Length` 값을 보내면 트랜잭션이 끝나는 시점에 기존 메세지의 끝과 새로운 메세지의 시작을 정확히 알 수 없게 됨.

5. 프록시와 게이트웨이는 `Connection` 헤더 규칙을 철저히 지켜야 함.

   - 이 둘은 메세지를 전달하거나 캐시를 넣기 전에 `Connection` 헤더에 명시된 모든 헤더 필드와 `Connection` 헤더를 제거해야 함.

6. `Keep-Alive` 커넥션은 `Connection` 헤더를 인식하지 못하는 프록시 서버와는 맺어지면 안됨.
7. `HTTP/1.0`을 따르는 기기로부터 받는 모든 `Connection` 헤더 필드는 무시해야 함.
   - 오래된 프록시 서버로부터 실수로 전달될 수 있음.
8. 클라이언트는, 응답 전체를 받기 전에 커넥션이 끊어졌을 경우, 별다른 문제가 없으면 요청을 다시 보낼 수 있게 준비되어 있어야 함.

### `Keep-Alive`와 멍청한(dumb) 프록시

#### `Connection` 헤더의 무조건 전달

- 프록시는 `Connection` 헤더를 이해하지 못해서 해당 헤더들을 삭제하지 않고 요청 그대로를 다음 프록시에 전달.
- `Connection` 헤더는 홉별 헤더이므로, 오직 한 개의 전송 링크에만 적용되며 다음 서버로 전달되어서는 안됨.
- 웹 서버가 프록시로부터 `Connection: Keep-Alive` 헤더를 받으면, 프록시와 커넥션을 유지하게 되고 응답 메세지에 `Keep-Alive`를 포함하여 전달하지만, 프록시는 `Keep-Alive`를 모른 채로 다시 클라이언트에게 `Connection: Keep-Alive`를 전달함.
- 클라이언트와 서버는 커넥션을 유지하고 있다고 생각하지만, 프록시는 `Keep-Alive`를 전혀 이해하지 못함.
  - 따라서 모든 데이터를 클라이언트에게 전달하고나서 서버가 커넥션을 끊기를 기다림.
    - 서버는 커넥션을 유지하기를 요청한 것으로 알고 있기 때문에 커넥션을 끊지 않음.
  - 클라이언트는 다음 요청을 보내기 시작하는데, 프록시는 이해하지 못하므로 브라우저는 아무런 응답 없이 로드 중이라는 표시.

> 잘못된 통신 때문에 브라우저는 자신이나 서버가 타임아웃이 나서 커넥션이 끊길 때까지 기다림.

#### 프록시와 홉별 헤더

- 프록시는 `Connection` 헤더와 `Connection` 헤더에 명시된 헤더들은 절대 전달하면 안됨.
- `Proxy-Authenticate`, `Proxy-Connection`, `Transfer-Encoding`, `Upgrade` 등.

### `Proxy-Connection` 살펴보기

- `Proxy-Connection`은 프록시를 별도로 설정할 수 있는 현대의 브라우저들에서 지원.
- 홉별 헤더들은 한 개의 특정 커넥션에서 쓰이고 그 이후에는 전달하면 안됨.
  - 홉별 헤더를 전달받은 서버가 그 헤더를 자신과 프록시 간의 커넥션에 대한 것으로 오해하면서 생기는 문제.
- 넷스케이프는 멍청한 프록시 문제를 해결하기 위해 브라우저에서 비표준인 `Proxy-Connection` 확장 헤더를 프록시에게 전달.
  - 웹 서버는 해당 헤더를 무시가힉 때문에 별 문제가 되지 않음.
  - 영리한 프록시(지속 커넥션 핸드셰이킹을 이해할 수 있는)라면, `Proxy-Connection`을 `Connection`으로 바꾸어 효과 얻을 수 있음.
- 이 방식은 클라이언트와 서버 사이에 한 개의 프록시만 있는 경우에서만 동작.
  - 멍청한 프록시 양 옆에 영리한 프록시가 있다면 잘못된 헤더를 만들어내는 문제가 다시 발생.
- 문제를 발생시키는 프록시들은 방화멱, 캐시 서버, 리버스 프록시 서버 가속기와 같이 네트워크 상에 보이지 않는 경우가 많으므로 `Proxy-Connection` 헤더를 보내지 못함.

> 보이지 않는 웹 애플리케이션들이 지속 커넥션을 명확히 구현하는 것은 중요.

### `HTTP/1.1`의 지속 커넥션

- `HTTP/1.1`에서는 `Keep-Alive` 커넥션을 지원하지 않는 대신, 설계가 더 개선된 지속 커넥션을 지원.
  - `Keep-Alive`의 상위 호환.
- 지속 커넥션은 기본으로 활성화 되어 있으며, 다은 커넥션을 끊기 위해서는 `Connection:close` 헤더를 명시해야 함.
- `Connection:close` 헤더가 없으면 응답 후에도 `HTTP/1.1` 커넥션을 계속 유지하자는 것으로 추정.

### 지속 커넥션의 제한과 규칙

1. 클라이언트가 요청에 `Connection:close` 헤더를 포함해 보냈으면, 클라이언트는 그 커넥션으로 추가적인 요청을 보낼 수 없음.
2. 커넥션에 있는 모든 메세지가 자신의 길이 정보를 정확히 가지고 있을 때만 커넥션을 지속시킬 수 있음.
   - 엔터티 본문은 정확한 `Content-Length`를 가지거나 청크 전송 인코딩으로 인코드 되어 있어야 함.
3. `HTTP/1.1` 프록시는 클라이언트와 서버 각각에 대해 별도의 지속 커넥션을 맺고 관리해야 함.
4. `HTTP/1.1` 프록시 서버는 클라이언트가 커넥션 관련 기능에 대한 클라이언트의 지원 범위를 알고 있지 않은 한 지속 커넥션을 맺으면 안됨.
   오래된 프록시;가 `Connection` 헤더를 전달하는 문제가 발생할 수 있음.
5. `HTTP/1.1` 기기는 `Connection` 헤더의 값과는 상관없이 언제든지 커넥션을 끊을 수 있음.
6. `HTTP/1.1` 애플리케이션은 중간에 끊어지는 커넥션을 복구할 수 있어야 함.
   - 클라이언트는 다시 보내도 문제가 없는 요청이라면 가능한 한 다시 보내야 함.
7. 클라이언트는 전체 응답을 받기 전에 커넥션이 끊어지면, 요청을 반복해서 보내도 문제가 없는 경우에는 요청을 다시 보낼 준비가 되어 있어야 함.
8. 하나의 사용자 클라이언트는 서버의 과부하를 방지하기 위해서, 넉넉잡아 두 개의 지속 커넥션만을 유지해야 함.
   - `n` 명의 사용자가 서버로 접근하려 한다면, 프록시는 서버나 상위 프록시에 넉넉잡아 약 `2n` 개의 커넥션을 유지해야 함.

---

## 파이프라인(pipelined) 커넥션

> 공유 `TCP` 커넥션을 통한 병렬 `HTTP` 요청

- `HTTP/1.1`은 지속 커넥션을 통해서 파이프라이닝 할 수 있음.
  - `Keep-Alive` 커넥션의 성능을 더 높여줌.
- 여러 개의 요청은 응답이 도착하기 전까지 큐에 쌓임.
- 대기 시간이 긴 네트워크 상황에서 네트워크 상의 왕복으로 인한 시간을 줄여서 성능을 높여줌.
- 파이프라인의 제약사항
  1. `HTTP` 클라이언트는 커넥션이 지속 커넥션인지 확인하기 전까지는 파이프라인을 이어서는 안됨.
  2. `HTTP` 응답은 요청 순서와 같게 와야 함.
  3. `HTTP` 클라이언트는 커넥션이 언제 끊어지더라도, 완료되지 않은 요청이 파이프라인에 있으면 언제든 다시 요청을 보낼 준비가 되어 있어야 함.
  4. `HTTP` 클라이언트는 `POST` 요청과 같이 반복해서 보낼 경우 문제가 생기는 요청은 파이프라인을 통해서 보내면 안됨.

---

## 다중(multiplexed) 커넥션

> 요청과 응답들에 대한 중재(실험적인 기술)

---

## 커넥션 끊기에 대한 미스터리

- 커넥션 관리에는 명확한 기준이 없음.

### '마음대로' 커넥션 끊기

- 언제든지 `TCP` 전송 커넥션을 끊을 수 있으며, 보통 커넥션은 메세지를 다 보낸 다음 끊음.
- 에러가 있는 상황에서는 헤더의 중간이나 다른 엉뚱한 곳에서 끊길 수 있음.
- 서버가 커넥션을 임의로 끊는 시점에 클라이언트가 메세지를 보낼 수도 있어서 문제가 생김.

### `Content-Length`와 `Truncation`

- 클라이언트나 프록시가 커넥션이 끊어졌다는 `HTTP` 요청을 받은 후, 실제 전달되 엔터티의 길이와 `Content-Length`의 값이 일치하지 않거나, `Content-Length` 자체가 존재하지 않으면 수신자는 데이터의 정확한 길이를 서버에 물어봐야 함.
- 만약 수신자가 캐시 프록시일 경우 응답을 캐시하면 안됨.
- 프록시는 `Content-Length`를 정정하려 하지 말고 메세지를 받은 그대로 전달해야 함.

### 커넥션 끊기의 허용, 재시도, 멱등성

- `HTTP` 애플리케이션은 예상치 못하게 커넥션이 끊어졌을 때에 적절히 대응할 수 있는 준비가 되어 있어야 함.
- 한 번 혹은 여러 번 실행됐는지에 상관없이 같은 결과를 반환한다면 그 트랜잭션은 멱등(`idempotent`)하다고 함.
  - `GET`, `HEAD`, `PUT`, `DELETE`, `TRACE`, `OPTION` 메서드.
- 클라이언트는 `POST`와 같이 멱등이 아닌 요청은 파이프라인을 통해 요청하면 안됨.
- 비멱등인 메서드나 순서에 대해 에이전트가 요청을 다시 보낼 수 있도록 기능을 제공한다 하더라도, 자동으로 재시도 하면 안됨.

> 대부분의 브라우저는 캐시된 `POST` 요청 페이지를 다시 로드하려고 할 때, 요청을 다시 보내기를 원하는지 묻는 대화상자를 보여줌.

### 우아한 커넥션 끊기

- `TCP` 커넥션은 양방향으로, 데이터를 읽거나 쓰기 위한 입력 큐와 출력 큐가 있음.

#### 전체 끊기와 절반 끊기

- 애플리케이션은 `TCP` 입력 채널과 출력 채널 중 한 개만 끊거나 둘 다 끊을 수 있음.
- `close()`를 호출하면 `TCP` 커넥션의 입력 채널과 출력 채널의 커넥션을 모두 끊음.(전체 끊기)
- `shutdown()`을 호출하면 입력 채널이나 출력 채널 중 하나를 개별적으로 끊음.(절반 끊기)

#### `TCP` 끊기와 리셋 에러

- 단순한 `HTTP` 애플리케이션은 전체 끊기만을 사용.
- 기기들에 예상치 못한 쓰기 에러를 발생하는 것을 예방하기 위해 절반 끊기를 사용해야 함.
- 보통은 커넥션의 출력 채널을 끊는 것이 안전함.
  - 커넥션의 반대편에 있는 기기는 모든 데이터를 버퍼로부터 읽고 나서 데이터 전송이 끝남과 동시에 커넥션이 끊겼다는 것을 알게 됨.
- 클라이언트에서 이미 끊긴 입력 채널에 데이터를 전송하면 서버의 운영체제는 `TCP 'connection reset by peer'` 메세지를 보냄.
  - 대부분의 운영체제는 이것을 심각한 에러로 취급하여 버퍼에 저장된 데이터를 모두 삭제.
    - 데이터를 읽으려 하면 에러를 받게 되고, 응답 데이터가 잘 도착하더라도 응답 데이터가 사라지게 됨.

#### 우아하게 커넥션 끊기

- 일반적으로 애플리케이션 자신의 출력 채널을 먼저 끊고 다른 쪽에 있는 기기의 출력 채널이 끊기는 것을 기다리는 것.
- 양쪽에서 더는 데이터를 전송하지 않을 것이라고 알려주면 커넥션은 리셋의 위험 없이 온전히 종료.
- 하지만 절반 끊기를 구현했다는, 검사해준다는 보장이 없기 때문에 출력 채널에 절반 끊기를 하고 난 후에도 데이터나 스트림의 끝을 식별하기 위해 입력 채널에 대해 상태 검사를 주기적으로 해야 함.
  - 애플리케이션이 특정 타임아웃 시간 내에 끊어지지 않으면, 애플리케이션은 리소스를 보호하기 위해 커넥션을 강제로 끊을 수 있음.
