# 커넥션 관리

## `TCP` 커넥션

- `HTTP` 통신은 패킷 교환 네트워크 프로토콜들의 계층화된 집합인 `TCP/IP`를 통해 이루어짐.
- `TCP/IP` 커넥션이 맺어지면 클라이언트와 서버 컴퓨터 간에 주고받는 메세지들은 손실 혹은 손상되거나 순서가 바뀌지 않고 안전하게 전달.
- `TCP` 커넥션 예시
  1. 브라우저에서 호스트 명 추출.
  2. 호스트 명에 대한 `IP` 주소 찾음.
  3. 브라우저가 포트 번호(`80`)을 얻음.
  4. 브라우저가 `IP:포트`로 `TCP` 커넥션 생성.
  5. 브라우저가 서버로 `HTTP` `GET` 요청 메세지 전송.
  6. 브라우저가 서버에서 온 `HTTP` 응답 메세지를 읽음.
  7. 커넥션 종료.

### 신뢰할 수 있는 데이터 전송 통로인 `TCP`

- `HTTP` 커넥션은 대부분 `TCP` 커넥션으로, `TCP` 커넥션 한 쪽에 있는 바이트들은 반대쪽으로 순서에 맞게 정확히 전달되는 신뢰할 만한 통신 방식을 제공.

### `TCP` 스트림은 세그먼트로 나뉘어 `IP` 패킷을 통해 전송된다

- `TCP`는 `IP` 패킷(`IP` 데이터 그램)이라는 작은 조각을 통해 데이터를 전송.
- `HTTP`는 프로토콜 스택에서 최상위 계층.

  |          `HTTP`           |          `HTTPS`          |
  | :-----------------------: | :-----------------------: |
  |                           | `HTTP`(애플리케이션 계층) |
  | `HTTP`(애플리케이션 계층) | `TLS` or `SSL`(보안 계층) |
  |           `TCP`           |           `TCP`           |
  |           `IP`            |           `IP`            |
  |    Network Interfaces     |    Network Interfaces     |

  - `HTTP`에 보안 기능을 더한 `HTTPS`는 `TLS` 혹은 `SSL`이라 불리는 암호화, 보안 계층이 포함.

- `HTTP`는 현재 연결되어 있는 `TCP` 커넥션을 통해서 메세지 데이터 스트림을 세그먼트라는 단위로 나누고, 세그먼트를 `IP` 패킷이라고 불리는 봉투에 담아서 전달.

  - `IP` 패킷 내용
    1. `IP` 패킷 헤더(보통 `20Byte`)
       - 발신지와 목적지 `IP` 주소, 크기, 기타 플래그
    2. `TCP` 세그먼트 헤더(보통 `20Byte`)
       - `TCP` 포트 번호, `TCP` 제어 플래그, 데이터의 순서와 무결성을 검사하기 위한 숫자 값
    3. `TCP` 데이터 조각(0 혹은 그 이상의 바이트)

### `TCP` 커넥션 유지하기

- `TCP`는 포트 번호를 이용해서 여러 개의 커넥션을 유지.

  - 커넥션 구성 요소

  ```
  <발신지 IP 주소, 발신지 포트, 수신지 IP 주소, 수신지 포트>
  ```

  > 네 가지 커넥션 구성 요소를 모두 똑같이 가리키고 있는 커넥션은 있을 수 없음.

### `TCP` 소켓 프로그래밍

- 운영체제는 `TCP` 커넥션의 생성과 관련된 여러 기능 제공.
- 이 중 소켓 `API`는 `UNIX` 운영체제 용으로 먼저 개발.
- 소켓 `API`를 사용하면 `TCP` 종단(`endpoint`) 데이터 구조를 생성하고, 원격 서버의 `TCP` 종단에 그 종단 데이터 구조를 연결하여 데이터 스트림을 읽고 쓸 수 있음.
- `TCP API`는 기본적인 네트워크 프로토콜의 핸드셰이킹, 그리고 `TCP` 데이터 스트림과 `IP` 패킷 간의 분할 및 재조립에 대한 모든 세부사항을 외부로부터 숨김.

---

## `TCP`의 성능에 대한 고려

- `HTTP` 트랜잭션의 성능은 그 아래 계층인 `TCP` 성능에 영향을 받음.

### `HTTP` 트랜잭션 지연

- 트랜잭션을 처리하는 시간은 `TCP` 커넥션을 설정하고, 요청을 전송하고, 응답 메세지를 보내는 것에 비하면 상당히 짧음.

> 대부분의 `HTTP` 지연은 `TCP` 네트워크 지연 때문에 발생.

- `HTTP` 트랜잭션 지연의 원인
  1. `DNS resolution` 인프라
  2. `TCP` 커넥션 설정 시간(동시에 여러 개)
  3. 웹 서버의 데이터 요청 확인 및 처리 시간
  4. 응답 시간
- 이외에도 하드웨어의 성능, 네트워크와 서버의 전송 속도, 요청과 응답 메세지의 크기, 클라이언트와 서버 간의 거리에 따라 다름.
- `TCP` 프로토콜의 기술적인 복잡성도 지연에 큰 영향.

### 성능 관련 중요 요소

- `TCP` 커넥션의 핸드셰이크 설정
- 인터넷의 혼잡을 제어하기 위한 `TCP`의 느린 시작(`slow start`)
- 데이터를 한데 모아 한 번에 전송하기 위한 네이글(`Nagle`) 알고리즘
- `TCP`의 편승(`piggyback`) 확인응답(`acknowledgment`)을 위한 확인응답 지연 알고리즘
- `TIME_WAIT` 지연과 포트 고갈

### `TCP` 커넥션 핸드셰이크 지연

- 새로운 `TCP` 커넥션을 열 때, `TCP` 소프트웨어는 커넥션을 맺기 위한 조건을 맞추기 위해 연속으로 `IP` 패킷 교환.
- 작은 크기의 데이터 전송에 커넥션이 사용된다면 `HTTP` 성능 저하 유발.
- 크기가 작은 `HTTP` 트랜잭션은 `50%` 이상의 시간을 `TCP`를 구성하는데 사용.

> 구성으로 인한 지연을 제거하기 위해 `HTTP`가 이미 존재하는 커넥션을 재활용 가능.

### 확인응답 지연

- 인터넷 자체가 패킷 전송을 완벽히 보장하지 않기 때문에, `TCP`는 성공적인 데이터 전송을 보장하기 위해서 자체적인 확인 체계를 가짐.
- 각 `TCP` 세그먼트는 순번과 데이터 무결성 체크섬을 가짐.
- 각 세그먼트의 수신자는 세그먼트를 온전히 받으면 작은 확인응답 패킷을 송신자에게 반환.
  - 확인응답은 그 크기가 작기 때문에, `TCP`는 같은 방향으로 송출되는 데이터 패킷에 확인응답을 편승(`piggyback`) 시킴.
  - `TCP`는 송출 데이터 패킷과 확인응답을 하나로 묶어 네트워크를 좀 더 효율적으로 사용.
  - 같은 방향으로 가는 데이터 패킷에 편승되는 경우를 늘리기 위해 많은 `TCP` 스택은 "확인응답 지연" 알고리즘을 구현.

> 하지만 요청과 응답 두 가지 형식으로만 이루어지는 `HTTP` 동작 방식은, 데이터 패킷 편승 기회를 감소시키고 막상 "확인응답 지연 알고리즘"으로 인한 지연이 발생하여 기능을 수정하거나 비활성화할 수 있음.

### `TCP` 느린 시작(`slow start`)

- `TCP`의 데이터 전송 속도는 시간에 따라 자체적으로 '튜닝'되어 조율함.
  - 이를 "`TCP` 느린 시작"이라고 함.
  - 인터넷의 급작스러운 부하와 혼잡을 방지하는 데 사용.
- `TCP` 느린 시작은 `TCP`가 한 번에 전송할 수 잇는 패킷의 수를 제한.
- 이 혼잡제어 기능 때문에, 새로운 커넥션은 이미 있는 커넥션보다 느림.

> 따라서 이미 존재하는 커넥션을 재사용하는 기능이 있음.

### 네이글(`Nagle`) 알고리즘과 `TCP_NODELAY`

- 애플리케이션이 어떤 크기의 데이터라도 `TCP` 스택으로 전송할 수 있도록 `TCP`는 데이터 스트림 인터페이스를 제공.
- "네이글 알고리즘"은 네트워크의 효율을 위해서 패킷을 전송하기 전에 많은 양의 `TCP` 데이터를 한 개의 덩어리로 합침.
  - 작은 `HTTP` 메세지는 패킷을 채우지 못하기 때문에 지연.
  - 확인응답 지연과 함께 쓰일 경우 형편없는 동작.

> 성능 향상을 위해서 `HTTP` 스택에 `TCP_NODELAY` 파라미터 값을 설정하여 "네이글 알고리즘"을 비활성화 하기도 함.

## `TIME_WAIT`의 누적과 포트 고갈

- `TIME_WAIT` 포트 고갈은 성능 측정 시에 심각한 성능 저하를 발생시키지만, 보통 실제 상황에서는 문제를 발생시키지 않음.(측정 시에는 `IP` 주소의 개수를 제한하고, 부하를 발생시킬 컴퓨터의 수는 적기 때문)
- `TCP` 커넥션의 종단에서 `TCP` 커넥션을 끊으면, 종단에서는 커넥션의 `IP` 주소와 포트 번호를 메모리의 작은 제어 영역에 기록.
- 이 정보를 통해 이전 커넥션과 관련된 패킷이 그 커넥션과 같은 주소와 포트 번호를 가지는 새로운 커넥션에 삽입되는 문제를 방지.
- 커넥션을 너무 많이 맺거나 대기 상태로 있는 제어 블록인 너무 많아지게 되면 느려질 수 있음.

---

## `HTTP` 커넥션 관리

### 흔히 잘못 이해하는 `Connection` 헤더

- `HTTP` 메세지는 클라이언트에서 서버(혹은 리버스 서버)까지 중개 서버들을 하나하나 거치면서 전달.
- `HTTP Connection` 헤더 필드는 커넥션 토큰을 쉼표로 구분하여 가지고 있음.
- `Connection` 헤더에 전달될 수 있는 토큰의 종류
  1. `HTTP` 헤더 필드명은, 이 커넥션에만 해당되는 헤더들을 나열.
     - 다음 커넥션에 전달하면 안됨.
  2. 임시적인 토큰 값은, 커넥션에 대한 비표준 옵션을 의미.
  3. `close` 값은, 커넥션이 작업이 완료되면 종료되어야 함을 의미.
- `Connection` 헤더에는 홉별(`hop-by-hop`) 헤더 명을 기술.

### 순차적인 트랜잭션 처리에 의한 지연

- 순차적인 처리로 인한 지연에는 물리적인 지연 뿐만 아니라, 심리적인 지연도 존재.
  - 사용자는 여러 개의 이미지가 동시에 로드되는 것을 더 좋아함.
- 순차적으로 로드하는 방식의 단점은, 특정 브라우저의 경우 객체를 화면에 배치하려면 객체의 크기를 알아야 하기 떄문에 모든 객체를 내려받기 전까지 텅 빈 화면을 보여주는 것.

---

## 병렬(parallel) 커넥션

> 여러 개의 `TCP` 커넥션을 통한 동시 `HTTP` 요청

### 병렬 커넥션은 페이지를 더 빠르게 내려받는다

- 하나의 커넥션으로 객체들을 로드할 때의 대역폭 제한과 대기 시간을 줄일 수 있다면 더 빠르게 로드할 수 있음.
- 각 커넥션의 지연 시간을 겹치게 하면 총 지연 시간을 줄일 수 있고, 클라이언트의 인터넷 대역폴을 한 개의 커넥션이 다 써버리는 것이 아니라면 나머지 객체들을 내려받는 데에 남은 대역폭을 사용할 수 있음.

### 병렬 커넥션이 항상 더 빠르지는 않다

- 일반적으로 더 빠르기는 하지만, 클라이언트의 네트워크 대역폭이 좁을 때, 성능 상의 장점은 거의 없어짐.
- 또한 다수의 커넥션은 메모리를 많이 소모하고 자체적인 성능 문제 야기.
- 수백개의 커넥션으로 인해 서버, 고부하 프록시의 과부하로 성능 저하가 발생할 수 있음.

> 브라우저는 실제로 적은 수의 병렬 커넥션만을 허용.  
> 서버는 특정 클라이언트로부터 과도한 수의 커넥션이 맺어졌을 경우, 임의로 끊을 수 있음.

### 병렬 커넥션은 더 빠르게 '느껴질 수' 있다

- 여러 객체가 동시에 보이면서 사용자는 더 빠르게 내려받고 있는 것처럼 느낄 수 있음.

> 총 다운로드 시간과 무관하게 전체에 여러 작업이 일어나는 것을 확인하면 더 빠르다고 여김.

### 병렬 커넥션의 단점

- 각 트랜잭션마다 새로운 커넥션을 맺고 끊기 때문에 시간과 대역폭이 소모.
- 각각의 새로운 커넥션은 `TCP`의 느린 시작 때문에 성능이 떨어짐.
- 실제로 연결할 수 있는 병렬 커넥션의 수에는 제한이 있음.

---

## 지속(persistent) 커넥션

> 커넥션을 맺고 끊는 데서 발생하는 지연을 제거하기 위한 `TCP` 커넥션의 재활용

- 웹 클라이언트는 보통 같은 사이트 내에서 여러 개의 커넥션을 맺는데, 보통 같은 사이트를 가리킴. 이를 사이트의 지역성(`site locality`)라고 함.
- 처리가 완료된 후에도 `TCP` 커넥션을 유지하여 앞으로 있을 `HTTP` 요청에 재사용할 수 있는데, 이러한 `TCP` 커넥션의 유지를 지속 커넥션이라고 함.
- 지속 커넥션은 클라이언트나 서버가 커넥션을 끊기 전까지는 트랜잭션 간에도 커넥션을 유지.

### 지속 커넥션 vs 병렬 커넥션

- 지속 커넥션의 장점
  - 커넥션을 맺기 위한 사전 작업과 지연을 줄여줌.
  - 튜닝된 커넥션 유지.
  - 커넥션의 수를 줄임.
- 지속 커넥션의 위험성
  - 계속 연결된 상태로 수많은 커넥션이 쌓일 가능성.
    > 로컬의 리소스, 원격의 클라이언트와 서버의 리소스에 불필요한 소모.
- 지속 커넥션은 병렬 커넥션과 함께 사용될 때 가장 효과적.

### `HTTP/1.0+`의 `Keep-Alive` 커넥션

- `HTTP/1.0` 브라우저와 서버들은 일찍부터 다소 실험적이었던 `Keep-Alive` 커넥션을 지원하기 위해 확장.
- 설계 상의 문제는 `HTTP/1.1`에서 수정.

### `Keep-Alive` 동작

- `Keep-Alive`는 사용하지 않기로 결정되어 `HTTP/1.1` 명세에서 빠졌으나, 아직도 `Keep-Alive` 핸드셰이크가 널리 사용되고 있기 때문에 `HTTP` 애플리케이션은 그것을 처리할 수 있게 개발해야 함.
- `Keep-Alive` 커넥션을 구현한 클라이언트는 요청에 `Connection:Keep-Alive` 헤더를 포함.
- 응답에 `Connection:Keep-Alive` 헤더가 없으면 서버가 `Keep-Alive`를 지원하지 않을 것이라 추정.

### `Keep-Alive` 옵션

- `Keep-Alive` 헤더는 커넥션을 유지하기를 바라는 요청.
  - 무조건 따를 필요가 없으며, 언제든지 현재의 `Keep-Alive`를 끊을 수 있음.
  - 처리되는 트랜잭션의 수를 제한할 수도 있음.
- `Keep-Alive`의 동작은 `Keep-Alive` 헤더의 쉼표로 구분된 옵션들로 제어.
  1. `timeout` 파라미터는 커넥션이 얼마간 유지될 것인지 의미.
  2. `max` 파라미터는 커넥션이 몇 개의 `HTTP` 트랜잭션을 처리할 때까지 유지될 것인지 의미.
  3. `Keep-Alive` 헤더는 진단이나 디버깅을 주목적으로 하는, 처리되지는 않는 임의의 속성들을 지원하기도 함.
- 서버가 5개의 추가 트랜잭션이 처리될 동안 커넥션을 유지하거나, 2분 동안 커넥션을 유지하라는 내용

  ```
  Connection: Keep-Alive
  Keep-Alive: max=5, timeout=120
  ```

### `Keep-Alive` 커넥션 제한과 규칙

### `Keep-Alive`와 멍청한(dumb) 프록시

#### `Connection` 헤더의 무조건 전달

#### 프록시와 홉별 헤더

### `Proxy-Connection` 살펴보기

### `HTTP/1.1`의 지속 커넥션

### 지속 커넥션의 제한과 규칙

---

## 파이프라인(pipelined) 커넥션

> 공유 `TCP` 커넥션을 통한 병렬 `HTTP` 요청

- `HTTP/1.1`은 지속 커넥션을 통해서 파이프라이닝 할 수 있음.
  - `Keep-Alive` 커넥션의 성능을 더 높여줌.
- 여러 개의 요청은 응답이 도착하기 전까지 큐에 쌓임.
- 대기 시간이 긴 네트워크 상황에서 네트워크 상의 왕복으로 인한 시간을 줄여서 성능을 높여줌.
- 파이프라인의 제약사항
  1. `HTTP` 클라이언트는 커넥션이 지속 커넥션인지 확인하기 전까지는 파이프라인을 이어서는 안됨.
  2. `HTTP` 응답은 요청 순서와 같게 와야 함.
  3. `HTTP` 클라이언트는 커넥션이 언제 끊어지더라도, 완료되지 않은 요청이 파이프라인에 있으면 언제든 다시 요청을 보낼 준비가 되어 있어야 함.
  4. `HTTP` 클라이언트는 `POST` 요청과 같이 반복해서 보낼 경우 문제가 생기는 요청은 파이프라인을 통해서 보내면 안됨.

---

## 다중(multiplexed) 커넥션

> 요청과 응답들에 대한 중재(실험적인 기술)

---

## 커넥션 끊기에 대한 미스터리

- 커넥션 관리에는 명확한 기준이 없음.

### '마음대로' 커넥션 끊기

- 언제든지 `TCP` 전송 커넥션을 끊을 수 있으며, 보통 커넥션은 메세지를 다 보낸 다음 끊음.
- 에러가 있는 상황에서는 헤더의 중간이나 다른 엉뚱한 곳에서 끊길 수 있음.
- 서버가 커넥션을 임의로 끊는 시점에 클라이언트가 메세지를 보낼 수도 있어서 문제가 생김.

### `Content-Length`와 `Truncation`

- 클라이언트나 프록시가 커넥션이 끊어졌다는 `HTTP` 요청을 받은 후, 실제 전달되 엔터티의 길이와 `Content-Length`의 값이 일치하지 않거나, `Content-Length` 자체가 존재하지 않으면 수신자는 데이터의 정확한 길이를 서버에 물어봐야 함.
- 만약 수신자가 캐시 프록시일 경우 응답을 캐시하면 안됨.
- 프록시는 `Content-Length`를 정정하려 하지 말고 메세지를 받은 그대로 전달해야 함.

### 커넥션 끊기의 허용, 재시도, 멱등성

- `HTTP` 애플리케이션은 예상치 못하게 커넥션이 끊어졌을 때에 적절히 대응할 수 있는 준비가 되어 있어야 함.
- 한 번 혹은 여러 번 실행됐는지에 상관없이 같은 결과를 반환한다면 그 트랜잭션은 멱등(`idempotent`)하다고 함.
  - `GET`, `HEAD`, `PUT`, `DELETE`, `TRACE`, `OPTION` 메서드.
- 클라이언트는 `POST`와 같이 멱등이 아닌 요청은 파이프라인을 통해 요청하면 안됨.
- 비멱등인 메서드나 순서에 대해 에이전트가 요청을 다시 보낼 수 있도록 기능을 제공한다 하더라도, 자동으로 재시도 하면 안됨.

> 대부분의 브라우저는 캐시된 `POST` 요청 페이지를 다시 로드하려고 할 때, 요청을 다시 보내기를 원하는지 묻는 대화상자를 보여줌.

### 우아한 커넥션 끊기

- `TCP` 커넥션은 양방향으로, 데이터를 읽거나 쓰기 위한 입력 큐와 출력 큐가 있음.

#### 전체 끊기와 절반 끊기

- 애플리케이션은 `TCP` 입력 채널과 출력 채널 중 한 개만 끊거나 둘 다 끊을 수 있음.
- `close()`를 호출하면 `TCP` 커넥션의 입력 채널과 출력 채널의 커넥션을 모두 끊음.(전체 끊기)
- `shutdown()`을 호출하면 입력 채널이나 출력 채널 중 하나를 개별적으로 끊음.(절반 끊기)

#### `TCP` 끊기와 리셋 에러

- 단순한 `HTTP` 애플리케이션은 전체 끊기만을 사용.
- 기기들에 예상치 못한 쓰기 에러를 발생하는 것을 예방하기 위해 절반 끊기를 사용해야 함.
- 보통은 커넥션의 출력 채널을 끊는 것이 안전함.
  - 커넥션의 반대편에 있는 기기는 모든 데이터를 버퍼로부터 읽고 나서 데이터 전송이 끝남과 동시에 커넥션이 끊겼다는 것을 알게 됨.
- 클라이언트에서 이미 끊긴 입력 채널에 데이터를 전송하면 서버의 운영체제는 `TCP 'connection reset by peer'` 메세지를 보냄.
  - 대부분의 운영체제는 이것을 심각한 에러로 취급하여 버퍼에 저장된 데이터를 모두 삭제.
    - 데이터를 읽으려 하면 에러를 받게 되고, 응답 데이터가 잘 도착하더라도 응답 데이터가 사라지게 됨.

#### 우아하게 커넥션 끊기

- 일반적으로 애플리케이션 자신의 출력 채널을 먼저 끊고 다른 쪽에 있는 기기의 출력 채널이 끊기는 것을 기다리는 것.
- 양쪽에서 더는 데이터를 전송하지 않을 것이라고 알려주면 커넥션은 리셋의 위험 없이 온전히 종료.
- 하지만 절반 끊기를 구현했다는, 검사해준다는 보장이 없기 때문에 출력 채널에 절반 끊기를 하고 난 후에도 데이터나 스트림의 끝을 식별하기 위해 입력 채널에 대해 상태 검사를 주기적으로 해야 함.
  - 애플리케이션이 특정 타임아웃 시간 내에 끊어지지 않으면, 애플리케이션은 리소스를 보호하기 위해 커넥션을 강제로 끊을 수 있음.
