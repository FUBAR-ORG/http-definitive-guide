# 캐시

- 웹 캐시는 자주 쓰이는 문서의 사본을 자동으로 보관하는 `HTTP` 장치.
  - 웹 요청이 캐시에 도착했을 때, 캐시된 로컬 사본이 존재한다면, 그 문서는 원 서버가 아니라 그 캐시로부터 제공.
- 캐시의 이점
  1. 불필요한 데이터 전송을 줄여서, 네트워크 요금으로 인한 비용을 줄여줌.
  2. 네트워크 병목을 줄여줌. 대역폭을 늘리지 않고도 페이지를 빨리 불러올 수 있음.
  3. 원 서버에 대한 요청을 줄여줌. 서버는 부하를 줄일 수 있으며 더 빨리 응답할 수 있게 됨.
  4. 페이지를 먼 곳에서 불러올수록 시간이 많이 걸리는데, 캐시는 거리로 인한 지연을 줄여줌.

---

## 불필요한 데이터 전송

- 복수의 클라이언트가 자주 쓰이는 원 서버 페이지에 접근할 때, 서버는 같은 문서를 클라이언트들에게 각각 한 번씩 전송하게 됨.
- 똑같은 바이트들이 네트워크를 통해 계속 반복해서 이동하게 되는데, 이 불필요한 데이터 전송은 값비싼 네트워크 대역폭을 잡아먹고, 전송을 느리게 만들며, 웹 서버에 부하를 줌.
- 캐시를 이용하면, 첫 번째 서버 응답은 캐시에 보관, 캐시된 사본이 뒤이은 요청들에 대한 응답으로 사용될 수 있기 때문에, 원 서버가 중복해서 트래픽을 주고받는 낭비가 줄어듬.

---

## 대역폭 병목

- 캐시는 네트워크 병목을 줄여줌.
- 많은 네트워크가 원격 서버보다 로컬 네트워크 클라이언트에 더 넓은 대역폭을 제공.
- 클라이언트들이 서버에 접근할 때의 속도는, 그 경로에 있는 가장 느린 네트워크의 속도와 같음.

> 만약 클라이언트가 빠른 `LAN`에 있는 캐시로부터 사본을 가져온다면, 캐싱은 성능을 대폭 개선 가능.(특히 큰 문서들에 대해서)

---

## 갑작스런 요청 쇄도(`Flash Crowds`)

- 캐싱은 갑작스런 요청 쇄도에 대처하기에 특히 중
- 갑작스런 사건으로 인해 많은 사람이 거의 동시에 웹 문서에 접근할 때 발생하는 불필요한 트래픽 급증은 네트워크와 웹 서버의 심각한 장애를 야기.

---

## 거리로 인한 지연

- 모든 네트워크 라우터는 제각각 인터넷 트래픽을 지연시킴.
- 클라이언트와 서버 사이의 라우터가 그다지 많지 않더라도, 빛의 속도 그 자체가 유의미한 지연을 유발.
- 보통 수준으로 복잡한 웹 페이지들은 빛의 속도로 인한 지연이 수 초에 달할 수도 있음.

> 캐시를 설치해서 문서가 전송되는 거리를 수천 킬로미터에서 수십 미터로 줄일 수 있음.

---

## 적중과 부적중

- 캐시가 세상 모든 문서의 사본을 저장하지는 않음.
- 캐시 적중(cache hit): 캐시에 요청이 도착했을 때, 그에 대응하는 사본이 있다면 그를 이용해 요청이 처리되는 것.
- 캐시 부적중(cache miss): 대응하는 사본이 없어 원서버로 전달되는 것.

### 재검사(Revalidation)

- 원 서버 콘텐츠는 변경될 수 있기 때문에, 캐시는 반드시 그들이 갖고 있는 사본이 여전히 최신인지 서버를 통해 때때로 점검해야 함.
- 이러한 '신선도 검사'를 "재검사"라고 부름.
- 효과적인 재검사를 위해 `HTTP`는 서버로부터 전체 객체를 가져오지 않고도 콘텐츠가 여전히 신선한지 빠르게 검사할 수 있는 특별한 요청을 정의.
- 캐시는 스스로 원한다면 언제든지 사본을 재검사 가능.
  - 네트워크 대역폭은 부족하기 때문에, 대부분의 캐시는 클라이언트가 사본을 요청하였으며 그 사본이 검사를 할 필요가 있을 정도로 충분히 오래된 경우에만 재검사 진행.
- 캐시는 캐시된 사본의 재검사가 필요할 때, 원 서버에 작은 재검사 요청을 보냄.
  - 콘텐츠가 변경되지 않았다면, 서버는 아주 작은 `304 Not Modified` 응답을 보냄.
    - 그 사본이 여전히 유효함을 알게된 캐시는 즉각 사본이 신선하다고 임시로 다시 표시한 뒤 그 사본을 클라이언트에 제공.
      > 이를 재검사 적중(느린 적중)이라 함.
    - 이것은 순수 캐시 적중보다 느림.
      - 원 서버와 검사를 할 필요가 있기 때문.
    - 캐시 부적중보다는 빠름.
      - 서버로부터 객체 데이터를 받아올 필요가 없기 때문.
- `HTTP`는 캐시된 객체를 재확인하기 위한 몇 가지 도구를 제공하는데, 그 중에서 가장 많이 쓰이는 것은 `If-Modified-Since` 헤더.
  - 서버에게 보내는 `GET` 요청에 이 헤더를 추가하면 캐시된 시간 이후에 변경되 경우에만 사본을 보내달라는 의미.
- `GET If-Modified-Since` 요청에서 버에 도착했을 때 일어날 수 있는 세 가지 상황.
  1. 서버 콘텐츠가 변경되지 않은 경우.
  2. 서버 콘텐츠가 변경된 경우.
  3. 객체가 삭제된 경우.

#### 재검사 적중

- 서버 객체가 변경되지 않았다면, 서버는 클라이언트에게 작은 `HTTP 304 Not Modified` 응답을 보냄.

#### 재검사 부적중

- 서버 객체가 캐시된 사본과 다르다면, 서버는 콘텐츠 전체와 함께 평범한 `HTTP 200 OK` 응답을 보냄.

#### 객체 삭제

- 서버 객체가 삭제되었다면, 서버는 `404 Not Found` 응답을 보내며, 캐시는 사본을 삭제.

### 적중률

- 캐시 적중률(캐시 적중비, 문서 적중률, 문서 적중비): 캐시가 요청을 처리하는 비율.
  - 적중률은 `0`에서 `1`까지의 값으로 되어 있지만, 퍼센트로 표현되기도 함.
    - `0%`는 모든 요청이 캐시 부적중, `100%`는 모든 요청이 캐시 적중.
- 캐시 관리자는 캐시 적중률이 `100%`에 근접하게 되는 것을 선호.
  - 실제 적중률은 다음에 달려있음.
    - 캐시가 얼마나 큰지
    - 캐시 사용자들의 관심사가 얼마나 비슷한지
    - 캐시된 데이터가 얼마나 자주 변경되거나 개인화되는지
    - 캐시가 어떻게 설정되어 있는지
- 적중률은 예측하기 어려운 것으로 악명이 높지만 오늘날 적중률 `40%`면 웹 캐시로 괜찮은 편.
- 다행히, 보통 크기의 캐시라도 충분한 분량의 자주 쓰이는 문서들을 보관하여 상당히 트래픽을 줄이고 개선 가능.

> 캐시는 유용한 콘텐츠가 캐시 안에 머무르도록 보장하기 위해 노력.

### 바이트 적중률

- 문서들이 모두 같은 크기인 것은 아니므로 문서 적중률이 모든 것을 말해주지 않음.
- 바이트 단위 적중률: 캐시를 통해 제공된 모든 바이트의 비율을 표현.
  - 이 측정값은 트래픽이 절감된 정도를 포착.
  - 바이트 단위 적중률 `100%`는 모든 바이트가 캐시에서 왔으며, 어떤 트래픽도 인터넷으로 나가지 않았음을 의미.
- 문서 적중률과 바이트 단위 적중률은 둘 다 캐시 성능에 대한 유용한 지표.
- 문서 적중률
  - 얼마나 많은 웹 트랜잭션을 외부로 보내지 않았는지 보여줌.
  - 트랜잭션은 고정된 소요 시간을 포함하게 되는데, 문서 적중률을 개선하면 전체 대기시간(지연)이 줄어듬.
- 바이트 단위 적중률
  - 얼마나 많은 바이트가 인터넷으로 나가지 않았는지 보여줌.
  - 바이트 단위 적중률의 개선은 대역폭 절약을 최적화.

### 적중과 부적중의 구별

- `HTTP`는 클라이언트에게 응답이 캐시 적중이었는지 아니면 원 서버 접근인지 말해줄 수 있는 방법을 제공하지 않음.
  - 두 경우 모두 응답 코드는 응답이 본문을 갖고 있음을 의미하는 `200 OK`
  - 캐시에 무슨 일이 일어났는지 설명하기 위해 `Via` 헤더에 추가 정보를 붙일 수 있음.
- 클라이언트가 응답이 캐시에서 왔는지 알아내는 한 가지 방법은 `Date` 헤더를 이용하는 것.
  - 응답의 `Date` 헤더 값을 현재 시각과 비교하여, 응답의 생성일이 더 오래되었다면 클라이언트는 응답이 캐시된 것임을 알아낼 수 있음.
- 클라이언트가 캐시된 응답을 감지하는 또 다른 방법은, 응답이 얼마나 오래되었는지 말해주는 `Age` 헤더를 이용하는 것.

---

## 캐시 토폴로지

- 캐시는 한 명의 사용자에게만 할당될 수도 있고 수천 명의 사용자들 간에 공유될 수도 있음.
- 한 명에게만 할당된 캐시를 개인 전용 캐시(private cache)라고 부름.
  - 개인만을 위한 캐시이므로, 한 명의 사용자가 자주 찾는 페이지를 담음.
- 공유된 캐시를 공용 캐시(public cache)라고 부름.
  - 사용자 집단에서 자주 쓰이는 페이지를 담음.

### 개인 전용 캐시

- 개인 전용 캐시는 많은 에너지나 저장 공간을 필요로 하지 않으므로, 작고 저렴할 수 있음.
- 웹 브라우저는 개인 전용 캐시를 내장.
- 대부분의 브라우저는 자주 쓰이는 문서를 개인용 컴퓨터의 디스크와 메모리에 캐시해 놓고, 사용자가 캐시 사이즈와 설정을 수정할 수 있도록 허용.
  - 캐시에 어떤 것들이 들어있는지 확인하기 위해 브라우저 안을 들여다보는 것도 가능.

### 공용 프록시 캐시

- 공용 캐시는 캐시 프록시 서버 혹은 프록시 캐시라고 불리는 특별한 종류의 공유된 프록시 서버.
- 프록시 캐시는 로컬 캐시에서 문서를 제공하거나, 혹은 사용자의 입장에서 서버에 접근.
- 공용 캐시에는 여러 사용자가 접근하기 때문에, 불필요한 트래픽을 줄일 수 있는 더 많은 기회가 있음.
  - 자주 찾는 객체를 단 한 번만 가져와 모든 요청에 대해 공유된 사본을 제공함으로써 네트워크 트래픽을 줄임.
- 프록시 캐시는 프록시를 위한 규칙에 따르며 수동 프록시를 지정하거나 프록시 자동설정 파일을 설정함으로써 브라우저가 프록시 캐시를 사용하도록 설정 가능.
- 인터셉트 프록시를 사용함으로써 브라우저의 설정 없이 `HTTP` 요청이 캐시를 통하도록 강제 가능.

### 프록시 캐시 계층들

- 작은 캐시에서 캐시 부적중이 발생했을 때 더 큰 부모 캐시가 그 트래픽을 처리하도록 하는 계층을 만드는 방식이 합리적일 수 있음.
- 클라이언트 주위에는 작고 저렴한 캐시를 사용하고, 계층 상단에는 많은 사용자들에 의해 공유되는 문서를 유지하기 위해 더 크고 강력한 캐시를 사용.
- 캐시 계층이 깊다면 요청은 캐시의 긴 연쇄를 따라가게 되고, 프록시 연쇄가 길어질수록 각 중간 프록시는 현저한 성능 저하 발생.

### 캐시망, 콘텐츠 라우팅, 피어링

- 단순 캐시 계층 대신 복잡한 캐시망을 만들고, 캐시망의 프록시 캐시는 복잡한 방법으로 서로 대화하여 어떤 부모 캐시와 대화할 것인지, 요청이 캐시를 완전히 우회해서 원 서버로 바로 가도록 할 것인지에 대한 캐시 커뮤니케이션을 동적으로 결정.
- 캐시망 안에서의 콘텐츠 라우팅을 위해 설계된 캐시들이 하는 일
  1. `URL`에 근거하여, 부모 캐시와 원 서버 중 하나를 동적으로 선택.
  2. `URL`에 근거하여, 특정 부모 캐시를 동적으로 선택.
  3. 부모 캐시에게 가기 전에, 캐시된 사본을 로컬에서 찾아봄.
  4. 다른 캐시들이 그들의 캐시된 콘텐츠에 부분적으로 접근할 수 있도록 허용하되, 그들의 캐시를 통한 인터넷 트랜짓(Internet transit)은 허용하지 않음.
- 한층 더 복잡한 캐시 사이의 관계는, 서로 다른 조직들이 상호 이득을 위해 그들의 캐시를 연결하여 서로를 찾아볼 수 있도록 함.
- 형제 캐시: 선택적인 피어링을 지원하는 캐시.
- `HTTP`는 형제 캐시를 지원하지 않기 때문에, 사람들은 인터넷 캐시 프로토콜(`ICP`)이나 하이퍼텍스트 캐시 프로토콜(`HTCP`) 같은 프로토콜을 이용해 `HTTP`를 확장.

---

## 캐시 처리 단계

### 단계 1: 요청 받기

- 캐시는 네트워크 커넥션에서의 활동을 감지하고, 들어오는 데이터를 읽어들임.
- 고성능 캐시는 여러 개의 들어오는 커넥션들로부터 데이터를 동시에 읽어들이고 메세지 전체가 도착하기 전에 트랜잭션 처리를 시작.

### 단계 2: 파싱

- 캐시는 요청 메세지를 여러 부분으로 파싱하여 헤더 부분을 조작하기 쉬운 자료구조에 담음.
  - 캐싱 소프트웨어가 헤더 필드를 처리하고 조작하기 쉽게 만듬.

### 단계 3: 검색

- 캐시는 `URL`을 알아내고 그에 해당하는 로컬 사본이 있는지 검사.
  - 로컬 복사본은 메모리, 디스크, 다른 컴퓨터 등에 저장.
- 전문적인 수준의 캐시는 객체를 로컬 캐시에서 가져올 수 있는지 판단하기 위해 빠른 알고리즘 사용.
- 문서를 로컬에서 가져올 수 없다면, 캐시는 상황이나 설정에 따라서 그것을 원 서버나 부모 프록시에서 가져오거나 실패 반환.
- 캐시된 객체는 서버 응답 본문과 원 서버 응답 헤더를 포함하고 있으므로, 객체가 얼마나 오랫동안 캐시에 머무르고 있었는지를 알려주는 기록이나 자주 사용되었는지 등에 대한 몇몇 메타 데이터 포함.

### 단계 4: 신선도 검사

- `HTTP`는 캐시가 일정 기간 동안 서버 문서의 사본을 보유할 수 있도록 해줌.
- 이 기간동안, 문서는 "신선한" 것으로 간주되고 캐시는 서버와의 접촉 없이 이 문서를 제공 가능.
- 캐시된 사본을 신선도 한계를 넘을 정도로 오래 갖고 있었다면, 그 객체는 "신선하지 않은" 것으로 간주되며, 캐시는 그 문서를 제공하기 전에 문서에 어떤 변경이 있었는지 서버와 재검사를 실행해야 함.
- `HTTP`의 신선도 검사 규칙은 매우 복잡.

### 단계 5: 응답 생성

- 캐시된 응답을 원 서버에서 온 것처럼 보이게 캐시는 캐시된 서버 응답 헤더를 토대로 응답 헤더를 생성.
  - 이 기저 헤더들은 캐시에 의해 수정되고 늘어남.
- 캐시는 클라이언트에 맞게 이 헤더를 조정해야 하는 책임이 있음.
- 캐시는 캐시 신선도 정보를 삽입하며(`Cache-Control`, `Age`, `Expires` 헤더), 요청이 프록시 캐시를 거쳐갔음을 알려주기 위해 종종 `Via` 헤더를 포함.
- 캐시는 `Date` 헤더를 조정해서는 안됨.
  - `Date` 헤더는 그 객체가 원 서버에서 최초로 생겨난 일시를 표현하는 것.

### 단계 6: 전송

- 응답 헤더가 준비되면, 캐시는 응답을 클라이언트에게 돌려줌.
- 프록시 캐시는 클라이언트와의 커넥션을 유지할 필요가 있음.
- 고성능 캐시는 종종 로컬 저장장치와 네트워크 `I/O` 버퍼 사이에서 문서의 콘텐츠 복사를 피함으로써 데이터를 효과적으로 전송하기 위해 노력.

### 단계 7: 로깅

- 대부분의 캐시는 로그 파일과 캐시 사용에 대한 통계를 유지.
- 각 캐시 트랜잭션이 완료된 후, 캐시는 통계 캐시 적중과 부적중 횟수에 대한 통계를 갱신하고 로그 파일에 요청 종류, `URL` 그리고 무엇이 일어났는지를 알려주는 항목을 추가.
- 가장 많이 쓰이는 캐시 로그 포맷
  - 스퀴드 로그 포맷(Squid log format)
  - 넷스케이프 확장 공용 로그 포맷(Netscape extended common log format)

> 많은 캐시 제품이 커스텀 로그 파일을 허용.

### 캐시 처리 플로 차트

---

## 사본을 신선하게 유지하기

- 오래된 데이터를 제공하는 캐시는 불필요.
- 캐시된 데이터는 서버의 데이터와 일치할 수 있도록 관리.
- `HTTP`는 어떤 캐시가 사본을 갖고 있는지 서버가 기억하지 않더라도, 캐시된 사본이 서버와 충분히 일치하도록 유지할 수 있게 해주는 단순한 메커니즘 보유.
  > 이 메커니즘을 문서 만료와 서버 재검사라고 함.

### 문서 만료

- `HTTP`는 `Cache-Control`과 `Expires`라는 특별할 헤더들을 이용해서 원 서버가 각 문서에 유효기간을 붙일 수 있게 해줌.
  - 이 헤더들은 콘텐츠가 얼마나 오랫동안 신선한 상태로 보일 수 있는지 좌우.
- 캐시 문서가 만료되기 전에, 캐시는 필요하다면 서버와의 접촉 없이 사본 제공 가능.
- 캐시된 문서가 만료되면, 캐시는 반드시 서버와 문서에 변경된 것이 있는지 검사하고 신선한 사본을 새 유효기간과 함께 얻어 와야 함.

### 유효기간과 나이

- `HTTP/1.0+ Expires`, `HTTP/1.1 Cache-Control: max-age` 응답 헤더를 이용해서 유효기간을 명시.
- 절대 시간은 컴퓨터의 시계가 올바르게 맞추어져 있을 것을 요구.

|           헤더           |                                                                                                          설명                                                                                                           |
| :----------------------: | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
| `Cache-Control: max-age` | `max-age` 값은 문서의 최대 나이를 정의. <br /> 최대 나이는 문서가 처음 생성된 이후부터, 제공하기엔 더 이상 신선하지 않다고 간주될 때까지 경과한 시간의 합법적인 최댓값(초 단위). <br /> `Cache-Control: max-age=484200` |
|        `Expires`         |                                        절대 유효기간을 명시. <br /> 만약 유효기간이 경과했다면, 그 문서는 더이상 신선하지 않음. <br /> `Expires: Fri, 05 Jul 2002, 05:00:00 GMT`                                        |

### 서버 재검사

- 캐시된 문서가 만료되었다는 것은, 그 문서가 원 서버에 현재 존재하는 것과 실제로 다르다는 것을 의미하지는 않음.
  > 검사할 시간의 되었음을 뜻함.
- 서버 재검사: 캐시가 원 서버에게 문서가 변경되었는지의 여부를 물어볼 필요가 있음.
  - 재검사 결과 콘텐츠가 변경되었다면, 캐시는 그 문서의 새로운 사본을 가져와 오래된 데이터 대신 저장한 뒤 클라이언트에게도 보내줌.
  - 재검사 결과 콘텐츠가 변경되지 않았다면, 캐시는 새 만료일을 포함한 새 헤더들만 가져와서 캐시 안의 헤더들을 갱신.
- 신선하지 않은 콘텐츠는 제공하지 않으면서 서버 트래픽을 절약하고 사용자 응답 시간을 개선.
- `HTTP` 프로토콜이 요구하는 캐시가 반환해야할 적절한 행동.
  - 충분히 신선한 캐시된 사본
  - 원 서버와 재검사되었기 때문에, 충분히 신선하다고 확신할 수 있는 캐시된 사본
  - 에러 메세지(재검사해야 하는 원 서버가 다운된 경우)
  - 경고 메세지가 부착된 캐시된 사본(부정확할 경우)

### 조건부 메서드와의 재검사

- `HTTP`의 조건부 메서드는 재검사를 효율적으로 만듬.
- `HTTP`는 캐시가 서버에게 "조건부 `GET`"이라는 요청을 보낼 수 있도록 해줌.
  - 이 요청은 서버가 갖고 있는 문서가 캐시가 갖고 있는 것과 다른 경우에만 객체 본문을 보내달라고 하는 것.
  - 신선도 검사와 객체를 받아오는 것은 하나의 조건부 `GET`으로 결합.
- 조건부 `GET`은 `GET` 요청 메세지에 특별한 조건부 헤더를 추가함으로써 시작.
  - 웹 서버는 조건이 참인 경우에만 객체를 반환.
- `HTTP`는 다섯 가지 조건부 요청 헤더를 정의.
  - 모든 조건부 헤더는 `If-` 접두어로 시작.
  - `If-Modified-Since`, `If-None-Match`는 캐시 재검사를 할 때 유용.

|            헤더             |                                                                                             설명                                                                                              |
| :-------------------------: | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
| `If-Modified-Since: <date>` |        만약 문서가 주어진 날짜 이후로 수정되었다면 요청 메서드를 처리. 캐시된 버전으로부터 콘텐츠가 변경되 경우에만 콘텐츠를 가져오기 위해 `Last-Modified` 서버 응답 헤더와 함께 사용         |
|   `If-None-Match: <tags>`   | 마지막 변경된 날짜를 맞춰보는 대신, 서버는 문서에 대한 일련번호와 같이 동작하는 특별한 태그를 제공 가능. `If-None-Match` 헤더는 캐시된 태그가 서버에 있는 문서의 태그와 다를 때만 요청을 처리 |

### `If-Modified-Since`: 날짜 재검사

- 흔히 `IMS` 요청으로 불리며, 서버에게 리소스가 특정 날짜 이후로 변경된 경우에만 요청한 본문을 보내달라고 함.
  - 만약 문서가 주어진 날짜 이후에 변경되었다면, 조건은 참이고 `GET` 요청은 평범하게 성공.
    - 새 문서가, 새로운 만료 날짜와 그 외 다른 정보들이 담긴 헤더들과 함께 캐시에게 반환.
  - 만약 문서가 주어진 날짜 이후에 변경되지 않았다면, 조건은 거짓이고 서버는 `304 Not Modified` 응답 메세지를 클라이언트에 돌려줌.
    - 효율을 위해 본문은 보내지 않음.
    - 응답은 헤더들을 포함하지만, 원래 돌려줘야할 것에서 갱신이 필요한 것만 보내줌.
      - 주로 만료 날짜.
- `If-Modified-Since` 헤더는 서버 응답 헤더의 `Last-Modified` 헤더와 함께 동작.
- 원 서버는 제공하는 문서에 최근 변경 일시를 붙임.
- 캐시가 캐시된 문서를 재검사 하려고 할 때, 캐시된 사본이 마지막으로 수정된 날짜가 담긴 `If-Modified-Since` 헤더를 포함

```shell
If-Modified-Since: <캐시된 마지막 수정일>
```

- 콘텐츠가 변경된 경우: 최근 변경 일시는 다르고 원 서버는 새 문서를 돌려줌.
- 콘텐츠가 변경되지 않은 경우: 최근 변경 일시가 같으며 `304 Not Modified` 응답을 돌려줌.
- 몇몇 웹 서버는 `If-Modified-Since`를 실제 날짜 비교로 구현하지 않으나, `IMS` 날짜와 최근 변경일 간의 문자열 비교를 수행하거나 함.
  - 캐시 만료와 관련된 동작에는 문제가 없음.

### `If-None-Match`: 엔터티 태그 재검사

- 최근 변경 일시 재검사가 적절히 행해지기 어려운 상황
  - 일정 시간 간격으로 다시 쓰여지지만 내용 변화 없이 같은 데이터를 포함하는 경우(변경 시각은 바뀜)
  - 전 세계의 캐시들이 그 데이터를 다시 읽어들이기엔 사소한 경우
  - 갖고 있는 페이지에 대한 최근 변경 일시를 정확하게 판별할 수 없는 경우
  - 1초보다 작은 간격으로 갱신되는 문서를 제공하는 경우
- 문서의 엔터티 태그를 새로운 버전으로 표현할 수 있으며, 엔터티 태그가 변경되었다면, 캐시는 새 문서의 사본을 얻기 위해 `If-None-Match` 조건부 헤더 사용 가능.
  - 서버 엔터티 태그가 변경되지 않았다면 `304 Not Modified` 응답 반환.
  - 서버 엔터티 태그가 변경되었다면 `200 OK` 응답과 함께 새 콘텐츠를 새 `ETag`와 함께 반환.
- 캐시가 객체에 대한 여러 개의 사본을 갖고 있는 경우, 그 사실을 서버에게 알리기 위해 하나의 `If-None-Match` 헤더에 여러 개의 엔터티 태그를 포함 가능.

```shell
If-None-Match: "v2.6"
If-None-Match: "v2.4", "v2.5", "v2.6"
If-None-Match: "foobar", "A34FAC0095", "Profiles In Courage"
```

### 약한 검사기와 강한 검사기

- 캐시는 캐시된 버전이 서버가 갖고 있는 것에 대해 최신인지 확인하기 위해 엔터티 태그를 사용.
  - 엔터티 태그와 최근 변경 일시는 둘다 캐시 검사기.
- 서버가 모든 캐시된 사본을 무효화시키지 않고 문서를 살짝 고칠 수 있도록 허용하고 싶은 경우, `HTTP/1.1`에서는 "그 정도면 같은 것"이라고 주장할 수 있도록 해주는 "약한 검사기(weak validator)"를 지원.
- "강한 검사기(strong validator)"는 콘텐츠가 바뀔 때마다 바뀜.
- "약한 검사기(weak validator)"는 어느 정도 콘텐츠 변경을 허용핮만, 콘텐츠의 중요한 의미가 변경되면 함께 변경.
- 조건부 특정 범위 가져오기 같은 몇몇 동작은 약한 검사기로는 불가능하기 때문에 서버는 `W/` 접두사로 약한 검사기 구분

```shell
ETag: W/"v2.6"
If-None-Match: W/"v2.6"
```

- 강한 엔터티 태그는 대응하는 엔터티 값이 어떻게 바뀌든 매번 같이 바뀌어야 함.
- 약한 엔터티 태그는 대응하는 엔터티에 유의미한 변경이 있을 때마다 같이 변경되어야 함.
- 원 서버는 서로 다른 두 엔터티에 대해 엔터티 태그 값을 재활용해서는 안됨.
  - 유효기간에 상관없이 캐시 항목은 임의의 긴 기간 동안 계속될 수 있음.
    - 따라서, 캐시가 과거의 특정 시점에서 얻은 검사기를 사용해서 캐시 항목을 다시 검사할 수 있음.

### 언제 엔터티 태그를 사용하고 언제 `Last-Modified` 일시를 사용하는가

- `HTTP/1.1` 클라이언트는 만약 서버가 엔터티 태그를 반환했다면, 반드시 엔터티 태그 검사기를 사용해야 함.
  - 만약 서버가 `Last-Modified` 값만을 반환했다면, 클라이언트는 `If-Modified-Since` 검사를 사용 가능.
  - 엔터티 태그와 최근 변경 일시 모두 사용 가능하다면, `HTTP/1.0`과 `HTTP/1.1` 캐시 모두 적절히 응답할 수 있도록 클라이언트는 각각을 위해 두 가지의 재검사 정책을 모두 사용.
- `HTTP/1.1` 원 서버는 실현 불가능하지만 않다면 엔터티 태그 검사기를 보내야 하며, 약한 엔터티 태그, `Last-Modified` 값을 같이 보내는 것도 선호.
  - `HTTP/1.1` 캐시나 서버가 `If-Modified-Since`와 엔터티 태그 조건부 헤더를 모두 받았다면, 요청의 모든 조건부 헤더 필드의 조건에 부합되지 않는 한 `304 Not Modified` 응답을 반환해서는 안됨.

---

## 캐시 제어

- `HTTP`에서 문서가 만료되기 전까지 얼마나 오랫동안 캐시될 수 있게 할 것인지 설정에 대한 우선순위

1. `Cache-Control: no-store` 헤더를 응답에 첨부 가능.
2. `Cache-Control: no-cache` 헤더를 응답에 첨부 가능.
3. `Cache-Control: must-revalidate` 헤더를 응답에 첨부 가능.
4. `Cache-Control: max-age` 헤더를 응답에 첨부 가능.
5. `Expires` 헤더를 응답에 첨부 가능.
6. 아무 만료 정보도 주지 않고 캐시가 스스로 체험적인(휴리스틱) 방법으로 결정하게 함.

### `no-cache`와 `no-store` 응답 헤더

- `HTTP/1.1`에서 `no-store`와 `no-cache` 헤더는 캐시가 검증되지 않은 캐시된 객체로 응답하는 것을 막음.

```shell
Cache-Control: no-store
Cache-Control: no-cache
Pragma: no-cache
```

- `no-store`가 표시된 응답은 캐시가 그 응답의 사본을 만드는 것을 금지.
  - 클라이언트에게 `no-store` 응답을 전달하고 나면 객체를 삭제할 것.
- `no-cache`가 표시된 응답은 로컬 캐시 저장소에 저장될 수 있지만, 먼저 서버와 재검사를 하지 않고서는 캐시에서 클라이언트로 제공될 수 없음.
  - "Do-Not-Serve-From-Cache-Without-Revalidation(재검사 없이 캐시에서 제공하지 마라)
- `Pragma: no-cache` 헤더는 `HTTP/1.0+`와 하위호환성을 위해 `HTTP/1.1`에 포함.
  - `HTTP/1.1` 애플리케이션은 `Pragma: no-cache`만 이해할 수 있는 `HTTP/1.0` 애플리케이션에 대응해야 하는 경우가 아니라면 `Cache-Control: no-cache`를 사용해야 함.

### `Max-Age` 응답 헤더

- `Cache-Control: max-age` 헤더는 신선하다고 간주되었던 문서가 서버로부터 온 이후로 흐른 시간이고, 초로 나타냄.
- `s-maxage` 헤더는 `max-age`처럼 행동하지만 공유된(공용) 캐시에만 적용.

```shell
Cache-Control: max-age=3600
Cache-Control: s-maxage=3600
```

- 서버는 최대 나이먹음을 `0`으로 설정함으로써, 캐시가 매 접근마다 문서를 캐시하거나 리프레시하지 않도록 요청 가능.

### `Expires` 응답 헤더

- `Expires` 헤더는 더이상 사용하지 않기를 권함.(`deprecated`)
- 초 단위의 시간 대신 실제 만료 날짜를 명시.
- 신선도 수명의 근사값은 만료일과 생성일의 초 단위 시간차를 계산하여 얻을 수 있음.

```shell
Expires: Fri, 05 Jul 2002, 05:00:00: GMT
```

- 문서를 항상 만료되도록 하기 위해 `Expires: 0` 응답 헤더를 돌려보내는 것은 문법 위반이며, 몇몇 소프트웨어와 문제를 일으킬 수 있음.
  - 가급적 받아들일 수 있어야 하나, 생성해서는 안됨.

### `Must-Revalidate` 응답 헤더

- 캐시는 성능을 개선하기 위해 신선하지 않은(만료된) 객체를 제공하도록 설정 가능.
- 캐시가 만료 정보를 엄격하게 따르길 원한다면, `Must-Revalidate` 응답 헤더 사용.

```shell
Cache-Control: must-revalidate
```

- `Cache-Control: must-revalidate` 응답 헤더는 캐시가 이 객체의 신선하지 않은 사본을 원 서버와의 최초의 재검사 없이는 제공해서는 안됨을 의미.
- 캐시는 자유롭게 신선한 사본을 제공 가능.
  - 만약 캐시가 `must-revalidate` 신선도 검사를 시도했을 때 원 서버가 사용할 수 없는 상태라면, 캐시는 반드시 `504 Gateway Timeout error`를 반환.

### 휴리스틱 만료

- 만약 응답이 `Cache-Control: max-age`, `Expires` 헤더 중 어느 것도 포함하지 않고 있다면, 캐시는 경험적인 방법(`Heuristic`)으로 최대 나이를 계산.
  - 계산 결과 얻은 최대 나이 값이 24시간보다 크다면 `Heuristic Expiration` 경고(경고 13) 헤더가 응답 헤더에 추가되어야 함.
    > 이 경고를 사용자가 볼 수 있게 해주는 브라우저는 거의 없음.
- `LM` 인자 알고리즘(유명한 휴리스틱 만료 알고리즘)은 문서가 최근 변경 일시를 포함하고 있다면 사용 가능.
  - 최근 변경 일시를 문서가 얼마나 자주 바뀌는지에 대한 추정에 사용.
  - 로직
    - 만약 캐시된 문서가 마지막으로 변경된 것이 상당히 예전이라면, 그것은 아마 안정적인 문저일 것이고 갑자기 바뀔 가능성은 별로 크지 않을 것이므로, 캐시에 더 오래 보관하고 있어도 안전.
    - 만약 캐시된 문서가 최근에 변경되었다면, 그것은 아마 자주 변경될 것이고, 따라서 우리는 그것을 서버와 재검사하기 전까지 짧은 기간 동안만 캐시.
- 실제 `LM` 인자 알고리즘은 캐시가 서버와 대화했을 때와 서버가 문서의 최근 변경 일시를 말해줬을 때의 시간차를 계산하고, 이 차의 일부분을 취하여 이 일부분을 캐시의 신선도 지속 기간으로 사용.
- `LM` 인자 알고리즘
  ```perl
  $마지막_수정_이후로_경과한_시간 = max(0, $서버의_Date - $서버의_Last_Modified);
  $서버_신선도_한계 = int($마지막_수정_이후로_경과한_시간 * $lm_인자);
  ```
- 휴리스틱 신선도 유지기간에 상한을 설정하여 지나치게 커지는 것을 막음.
- 최근 변경일조차 없다면 캐시는 판단 근거가 될 정보를 그다지 갖지 못한 것.
  - 캐시는 아무런 단서가 없는 문서에 대해 기본 신선도 유지기간을 설정.

> 캐시의 만료 기본값을 신중하게 선택해야 함!

### 클라이언트 신선도 제약

- 리프레시 동작은 `Cache-Control` 요청 헤더가 추가된 `GET` 요청을 발생시켜서, 강제로 재검사하거나 서버로부터 콘텐츠를 무조건 가져옴.
  - 정확한 리프레시 동작은 각 브라우저나 문서, 중간 캐시 설정에 달림.
- 클라이언트는 `Cache-Control` 요청 헤더를 사용하여 만료 제약을 엄격하거나 느슨하게 가능.

|                               지시어                               |                                                                                       목적                                                                                        |
| :----------------------------------------------------------------: | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
| `Cache-Control: max-stale` <br /> `Cache-Control: max-stale = <s>` | 캐시는 신선하지 않은 문서라도 자유롭게 제공. 만약 `<s>` 매개변수가 지정되면. 클라이언트는 만료시간이 그 매개변수의 값만큼 지닌 문서도 받아들임. <br /> ※ 캐싱 규칙을 느슨하게 함. |
|                  `Cache-Control: min-fresh = <s>`                  |                                    클라이언트는 지금으로부터 적어도 `<s>`초 후까지 신선한 문서만을 받아들임. <br /> ※ 캐싱 규칙을 엄격하게 함.                                    |
|                   `Cache-Control: max-age = <s>`                   |        캐시는 `<s>`초보다 오랫동안 캐시된 문서를 반환 불가. <br /> ※ 나이가 유효기간을 넘어서게 되는 `max-stale` 지시어가 함께 설정되지 않는 이상 캐싱 규칙을 엄격하게 함.        |
|        `Cache-Control: no-cache` <br /> `Pragma: no-cache`         |                                                          클라이언트가 캐시된 리소스를 재검사하기 전에는 받아들이지 않음.                                                          |
|                     `Cache-Control: no-store`                      |                                                                 저장소에서 문서의 흔적을 삭제함.(민감한 정보 등)                                                                  |
|                  `Cache-Control: only-if-cached`                   |                                                                    클라이언트는 캐시에 들어있는 사본만을 원함.                                                                    |

### 주의할 점

- 문서 만료는 완벽한 시스템이 아님.
  - 실수로 유효기간을 까마득한 미래로 설정해버린다면, 만료되기 전까지는 그 문서에 대한 어떠한 변경도 캐시에 반영되지 않음.

> 이런 이유로 많은 퍼블리셔가 유효기간을 길게 잡지 않음.

> 오히려 아예 유효기간을 사용조차 하지 않아서, 문서가 얼마나 오랫동안 신선할 것인지 캐시가 알기 어렵게 되는 경우도 많음.

---

## 캐시 제어 설정

- 웹 서버들은 캐시 제어와 만료 `HTTP` 헤더들을 설정하는 서로 다른 메커니즘을 제공.

### 아파치로 `HTTP` 헤더 제어하기

- 아파치 웹 서버는 `HTTP` 캐시 제어 헤더를 설정할 수 있는 여러 가지 메커니즘을 제공.
- 많은 것이 디폴트로는 가능하지 않게 되어 있으므로, 활성화시킬 필요가 있음.

#### `mod_headers`

- `mod_headers` 모듈은 개별 헤더들을 설정할 수 있게 해줌.
- 이 모듈이 로드되면, 개별 `HTTP` 헤더를 설정할 수 있는 지시어를 이용해 아파치 설정 파일에 설정을 추가 가능.
- 개별 콘텐츠에 헤더들을 연결시키기 위해 아파치 정규식과 필터를 조합하여 사용 가능.
- 어떤 디렉터리의 모든 `HTML` 파일을 캐시되지 않도록 설정하는 예
  ```apache
  <Files *.html>
    Header set Cache-Control no-cache
  </Files>
  ```

#### `mod_expires`

- `mod_expires` 모듈은 적절한 만료 일자가 담긴 `Expires` 헤더를 자동으로 생성하는 프로그램 로직을 제공.
- 이 모듈은 문서에 마지막으로 접근한 날 혹은 수정한 날 이후의 일정 시한으로 유효기간을 설정할 수 있게 해줌.
- 파일 종류별로 다른 만료 날짜를 설정할 수 있게 해주며, 편리한 기술 형식 사용.
  ```apache
  ExpiresDefault A3600
  ExpiresDefault M86400
  ExpiresDefault "access plus 1 week"
  ExpiresDefault text/html "modification plus 2 days 6 hours 12 minutes"
  ```

#### `mod_cern_meta`

- `mod_cern_meta` 모듈은 `HTTP` 헤더들의 파일을 특정 객체와 연결시켜 줌.
- 이 모듈을 켜면 제어하고자 하는 파일에 각각 대응되는 메타 파일들을 생성하게 되므로, 각 메타 파일에 원하는 헤더를 추가하면 됨.

### `HTTP-EQUIV`를 통한 `HTML` 캐시 제어

- `HTTP` 서버 응답 헤더는 문서의 만료와 캐시 제어 정보를 돌려주기 위해 사용.
- 웹 서버는 제공할 문서에 올바른 캐시 제어 헤더들을 부여하기 위해 설정 파일들과 상호작용.
- `HTML2.0`은 `<META HTTP-EQUIV>` 태그를 정의하여 웹 서버 설정 파일과의 상호작용 없이도 쉽게 `HTML` 문서에 `HTTP` 헤더 정보 부여 가능.
- 이 선택적인 태그는 `HTML` 문서 최상단에 위치하여 문서와 연동되어야 하는 `HTTP` 헤더들을 정의.
  ```html
  <html>
    <head>
      <title>My document</title>
      <meta http-equiv="Cache-Control" content="no-cache" />
    </head>
  </html>
  ```
- 이 `HTTP-EQUIV` 태그는 원래 웹 서버에서 사용되도록 의도.
  - 웹 서버는 `HTML`에서 `<meta http-equiv>` 태그를 파싱하여 `HTTP` 응답에 정해진 헤더를 삽입.
- 그러나 이 기능을 지원하는 웹 서버나 프록시는 거의 없음.
  - 서버의 부하를 가중시키고, 설정값이 정적이고 `HTML`을 제외한 다른 타입의 파일은 지원하지 않기 때문.
- `HTTP-EQUIV`를 지원하는 브라우저들은 중간의 프록시 캐시와는 다른 캐시 제어 규칙을 적용할 것이기 때문에 캐시 만료에 대한 동작에 혼란을 초래할 수 있음.

> `<META HTTP-EQUIV>` 태그는 문서의 캐시 동작을 제어하는 서투른 방법.

> 문서의 캐시 제어 요청과 커뮤니케이션하는 확실한 방법은 올바르게 설정된 서버가 보내온 `HTTP` 헤더를 이용하는 것.

---

## 자세한 알고리즘

### 나이와 신선도 수명

- 캐시는 신선도를 위해 단 두 가지 값(캐시된 사본의 나이, 신선도 수명)만 계산하면 됨.
  - 캐시된 사본의 나이가 신선도 수명보다 작으면 사본은 제공해주기에 충분히 신선한 것.

```perl
$충분히_신선한가 = ($나이 < $신선도_수명);
```

- 문서의 나이: 서버가 문서를 보낸(서버가 마지막으로 재검사한) 후 그 문서가 '나이를 먹은' 시간의 총합.
  - 캐시는 문서 응답이 업스트림 캐시에서 왔는지 서버에서 왔는지 모르기 때문에, 문서가 완전히 새롭다고 가정 불가.
  - `Age` 헤더를 통해 명시적으로 혹은 서버가 생성한 `Date` 헤더를 통해 계산하는 방법으로 문서의 나이를 판별.
- 문서의 신선도 수명: 문서가 신선하다고 볼 수 있는 수명.
  - 신선도 수명 계산에는 문서의 유효기간과 신선도에 영향을 주는 클라이언트의 모든 요청을 고려.

> 캐시는 서버 만료 정보와 클라이언트 신선도 요구사항을 조합해서 최대 신선도 수명 판별.

### 나이 계산

- 응답의 나이: 서버에서 생성되었을(서버로부터 재검사되었을) 때부터 지금까지의 총 시간.
  - 나이는 응답이 인터넷상의 라우터, 게이트웨이들 사이를 떠돌아다닌 시간(중개 캐시에 기록)과 응답이 캐시에 머물렀던 시간을 포함.

```perl
$겉보기_나이 = max(0, $응답을_받은_시각 - $Date_헤더값);
$보정된_겉보기_나이 = max($겉보기_나이, $Age_헤더값);
$응답_지연_추정값 = ($응답을_받은_시각 - $요청을_보낸_시각);
$문서가_우리의_캐시에_도착했을_때의_나이 = $보정된_겉보기_나이 + $응답_지연_추정값;
$사본이_우리의_캐시에_머무른_시간 = $현재_시각 - $응답을_받은_시각;

$나이 = $문서가_우리의_캐시에_도착했을_때의_나의 + $사본이_우리의_캐시에_머무른_시간;
```

- 캐시는 응답이 캐시에 도착했을 때, `Date`나 `Age` 헤더를 분석해서 얼마나 오래된 것인지 알 수 있음.
  - 둘을 합하면 응답의 전체 나이.
- `HTTP`는 클록 스큐(`clock skew`)와 네트워크 지연을 보상하기 위한 로직이 있으나, 기본 계산은 다음과 같음.
  ```perl
  $나이 = $문서가_우리의_캐시에_도착했을_때의_나의 + $사본이_우리의_캐시에_머무른_시간;
  ```
- 캐시는 캐시된 사본이 로컬에서 얼마나 오랫동안 캐시되었는지 아주 쉽게 알아낼 수 있음.
- 하지만, 캐시에서 온 응답의 나이를 알아내는 것은 어려움.

#### 겉보기 나이는 `Date` 헤더에 기반한다.

- 모든 컴퓨터가 똑같이 정확한 시계를 갖고 있다면 캐시된 문서의 나이는 현재시간에서 서버가 문서를 보낸 시간을 뺀 값.
  - 모든 시계가 잘 동기화되지 않아 시계 값이 차이가 남.

```perl
$겉보기_나이 = $응답을_받은_시각 - $Date_헤더값;
$문서가_우리의_캐시에_도착했을_때의_나이 = $겉보기_나이;
```

- 웹 애플리케이션, 특히 캐시 프록시는 시계 값이 극단적으로 차이 나는 서버와 상호작용 하는 경우를 대비해야 함.
  - 클록 스큐: 두 컴퓨터의 시계 설정 차이로 인한 문제.
  - 클록 스큐 때문에 겉보기 나이는 부정확하거나 음수가 됨.
- 나이가 음수가 되는 일이 있다면, 그것을 `0`으로 만들어야 함.
  ```perl
  $겉보기_나이 = max(0, $응답을_받은_시각 - $Date_헤더값);
  $문서가_우리의_캐시에_도착했을_때의_나이 = $겉보기_나이;
  ```

> `Date` 헤더가 원래의 원 서버 날짜를 서술한다는 사실에 주의.  
> 프록시와 캐시는 이 날짜를 절대로 변경하면 안됨.

#### 점층적 나이 계산

- `HTTP/1.1`은 동기화된 시계라는 것이 존재하지 않는다는 문제에 대한 우회책으로, 문서가 프록시나 캐시를 통과할 때마다 그 장치들이 `Age` 헤더에 상대적인 나이를 누적해서 더하도록 함.
  - 서버 간의 시간 비교나 종단 간의 시간 비교를 필요로 하지 않음.
- `Age` 헤더 값은 문서가 프록시들을 통과하면서 점점 늘어남.
- `HTTP/1.1`을 이해하는 애플리케이션은 문서가 각 애플리케이션에 머무른 시간과 네트워크 사이를 이동한 시간만큼 `Age` 헤더의 값을 늘려줘야 함.
  - 각 중간 애플리케이션은 자신의 내부 시계를 이용해서 쉽게 문서의 체류 시간 계산 가능.
- 비 `HTTP/1.1` 장치는 `Age` 헤더를 인식하지 못하고 그 헤더를 고치지 않거나 삭제해버림.
  > 이로 인해 `Age` 헤더는 상대 나이에 대한 모자란 추정값인 상태로 남아있게 됨.
- 이 상대 나이 값은 `Date` 기반 나이와는 별개로 계산되어, 두 나이 추정값 중 보수적인(가장 큰) 것이 선택.
  - 다른 서버에서 넘어온 `Date` 값이나 나이 계산 값은 실제보다 작게 계산된 값일 수 있기 때문.

```perl
$겉보기_나이 = max(0, $응답을_받은_시각 - $Date_헤더값);
$보정된_겉보기_나이 = max($겉보기_나이, $Age_헤더값);
$문서가_우리의_캐시에_도착했을_때의_나이 = $보정된_겉보기_나이;
```

#### 네트워크 지연에 대한 보상

- 트랜잭션은 느려질 수 있음.
  > 캐시를 하는 주요한 동기.
- 매우 느린 네트워크나 과부하가 걸린 서버에서 문서가 네트워크나 서버의 교통 혼잡에 긴 시간동안 갇혀있었던 경우 상대 나이 계산은 문서의 나이에 대한 상당히 모자란 추정이 됨.
- `Date` 헤더는 언제 문서가 원 서버를 떠났는지 나타내지만, 문서가 캐시로 옮겨가는 도중에 얼마나 시간을 소비했는지는 말해주지 않음.
  - 문서가 프록시들과 부모 캐시의 긴 연쇄를 거쳐서 왔다면 네트워크 지연은 상당한 수준일 것.
- 서버에서 캐시로의 단방향 네트워크 지연을 측정하기는 어렵지만, 왕복 지연을 계산하는 것은 상대적으로 쉬움.
  - 캐시는 언제 문서를 요청했고 언제 도착했는지 암.
- `HTTP/1.1`은 이를 이용해 계산한 전체 왕복 시간을 더함으로써 네트워크 지연을 보수적으로 교정.

```perl
$겉보기_나이 = max(0, $응답을_받은_시각 - $Date_헤더값);
$보정된_겉보기_나이 = max($겉보기_나이, $Age_헤더값);
$응답_지연_추정값 = ($응답을_받은_시각 - $요청을_보낸_시각);
$문서가_우리의_캐시에_도착했을_때의_나이 = $보정된_겉보기_나이 + $응답_지연_추정값;
```

### 완전한 나이 계산 알고리즘

- 문서에 대한 요청이 캐시에 도착했을 때, 그 문서의 현재 나이를 계산하기 위해 그 문서가 캐시에 얼마나 오랫동안 머물렀는지 알 필요가 있음.
- `HTTP/1.1` 나이 계산 알고리즘
  ```perl
  $나이 = $문서가_우리의_캐시에_도착했을_때의_나의 + $사본이_우리의_캐시에_머무른_시간;
  ```

### 신선도 수명 계산

- 신선도 수명은 서버와 클라이언트의 제약조건에 의존.
- 서버는 문서가 얼마나 자주 변경되어 발행되는지에 대한 정보를 갖고 있을 수도 있음.
- 클라이언트는 다른 가이드라인을 갖고 있을 수도 있음.

> 캐시는 사용자를 위해 봉사. 반드시 그들의 요구에 충실히 따라야 함.

### 완전한 서버 신선도 알고리즘

- 서버 신선도 한계 알고리즘

  ```perl
  sub 서버_신선도_한계 {
    local($휴리스틱, $서버_신선도_한계, $마지막으로_변경된_시각);

    $휴리스틱 = 0;

    if ($Max_Age_값이_설정되었나) {
      $서버_신선도_한계 = $Max_Age_값;
    } elsif ($Expires_값이_설정되었나) {
      $서버_신선도_한계 = $Expires_값 - $Date_값;
    } elsif ($Last_Modified_값이_설정되었나) {
      $마지막으로_변경된_시각 = max(0, $Date_값 - $Last_Modified_값);
      $서버_신선도_한계 = int($마지막으로_변경된_시각 * $lm_인자);
      $휴리스틱 = 1;
    } else {
      $서버_신선도_한계 = $캐시_최소_수명_기본값;
      $휴리스틱 = 1;
    }

    if ($휴리스틱) {
      if ($서버_신선도_한계 > $캐시_최대_수명_기본값) {
        $서버_신선도_한계 = $캐시_최대_수명_기본값;
      }
      if ($서버_신선도_한계 < $캐시_최소_수명_기본값) {
        $서버_신선도_한계 = $캐시_최소_수명_기본값;
      }
    }
    return($서버_신선도_한계);
  }
  ```

- 전체 과정

  ```perl
  sub 클라이언트가_수정한_신선도_한계 {
    $나이_한계 = 서버_신선도_한계();

    if ($Max_Stale_값이_설정되었나) {
      if ($Max_Stale_값 == $INT_MAX) {
        $나이_한계 = $INT_MAX;
      } else {
        $나이_한계 = 서버_신선도_한계() + $Max_Stale_값;
      }
    }

    if ($Min_Fresh_값이_설정되었나) {
      $나이_한계 = min($나이_한계, 서버_신선도_한계() - $Min_Fresh_값);
    }

    if ($Max_Age_값이_설정되었나) {
      $나이_한계 = min($나이_한계, $Max_Age_값);
    }
  }
  ```

> 나이가 신선도 한계보다 작다면 문서는 "충분히 신선".

---

## 캐시와 광고

- 캐시는 성능을 개선하고 트래픽을 줄임.

> 사용자를 도와 더 좋은 경험을 제공하고, 네트워크 사업자들이 트래픽을 줄일 수 있도록 도와줌.

### 광고 회사의 딜레마

- 콘텐츠 제공자들은 캐시를 좋아함.
  - 캐시가 모든 곳에 있다면 대용량 멀티 프로세서 웹 서버, 네트워크 서비스 요금이 최적화 되고, 캐시를 통해 더 많은 콘텐츠를 소비하고 광고를 보게 할 수 있음.
- 하지만, 많은 콘텐츠 제공자가 광고를 통해 돈을 범.
  - 캐시는 원 서버가 실제 접근 횟수를 알 수 없게 숨기므로 캐싱이 완벽하게 동작한다면 원 서버는 `HTTP` 접근을 전혀 수신하지 않게 됨.
    - 인터넷 캐시가 그 접근들을 모두 흡수하기 때문.

### 퍼블리셔의 응답

- 캐시가 광고 시청 수를 가로채지 못하도록 모든 종류의 "캐시 무력화" 기법을 사용함.
  - 광고를 `CGI` 게이트웨이를 통해 제공.
  - 매 접근마다 광고 `URL`을 고쳐 씀.
- 캐시 무력화 기법은 단지 프록시 캐시만에 대한 것이 아님.
  - 모든 웹 브라우저에 켜져 있는 캐시를 주요 대상으로 함.
- 광고의 시청 수를 관리하려는 과하게 의욕적인 시도는 몇몇 콘텐츠 제공자가 그들의 사이트에 대한 캐싱의 긍정적인 효과를 감소.
- 해결 방안
  1. 모든 접근에 대해 원 서버와 재검사하도록 캐시를 설정하는 것.
     - 매 접근마다 원 서버에 캐시 적중이 있었음을 알리지만 보통 본문 데이터를 전송하지 않음.
       - 트랜잭션을 느리게 만듬.
  2. 로그 마이그레이션

### 로그 마이그레이션

- 다른 해결책 중 하나는 서버로 요청이 가지 않도록 하는 것.
- 캐시는 모든 적중의 로그를 유지 가능.
  - 캐시는 이 로그를 서버에게 나누어 줄 수 있음.
  - 큰 캐시 제공자들은 영향력 있는 콘텐츠 제공자들을 기쁘게 하기 위해 그들에 대한 캐시 로그를 수동으로 처리해서 관리.
  - 적중 로그는 그 크기 때문에 옮기기 어려움.
    - 캐시 로그는 개별 콘텐츠 제공자 별로 분리될 수 있도록 표준화, 조직되어 있지 않음.
    - 인증과 프라이버시 이슈도 포함.
- 효율적인 로그 재분산을 위한 전략들이 제안되어 왔지만 충분히 발전된 것은 없음.
  - 효과를 보려면 공동 사업 협력이 필요함.

### 적중 측정과 사용량 제한

- `RFC 2227`: "`HTTP`를 위한 간단한 캐시 적중량 측정과 사용량 제한"(Simple Hit Metering and Usage-Limiting for `HTTP`)
  - 이 프로토콜은 `HTTP`에 때때로 특정 `URL`에 대한 캐시 적중 횟수를 정기적으로 서버에게 돌려주는 `Meter`라고 하는 새 헤더 하나를 추가.
    - 서버가 캐시된 문서가 적중한 횟수의 정기적인 업데이트를 캐시로부터 받음.
  - 서버는 캐시가 서버에 보고해야 하기 전까지, 문서를 제공할 수 있는 횟수나 소모할 수 잇는 처리 시간을 제어 가능.
    > 이를 사용량 제한이라 함.
    - 캐시가 원 서버에 보고하기 전에 캐시된 리소스가 얼마나 많이 사용될 수 있는지 서버가 제어할 수 있게 함.
