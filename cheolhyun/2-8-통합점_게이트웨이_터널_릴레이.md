# 통합점: 게이트웨이, 터널, 릴레이

- `HTTP` 위에 다른 프로토콜을 얹으려는 개발자들에게는 `HTTP`가 기본 구성 요소.
  - `HTTP`만 허용하는 방화벽이 있는 회사에서 다른 프로토콜로 통신하는 트래픽을 `HTTP`로 감싸서 터널링하거나 릴레이하는 것.)
- `HTTP`는 웹에 있는 모든 리소스에 대한 프로토콜로 사용됐으며, 애플리케이션 간에 서로 다른 프로토콜을 상호 운용하는 용도로 사용하기도 함.

## 게이트웨이

- 웹에 더 복잡한 리소스를 올려야 할 필요가 생기면서, 모든 리소스를 한 개의 애플리케이션으로만 처리할 수 없게 됨.
  - 해결책: 인터프리터 같이 리소스를 받기 위한 경로를 안내하는 역할을 하는 "게이트웨이"를 고안.
- 게이트웨이: 리소스와 애플리케이션을 연결하는 역할.
  - 애플리케이션은 게이트웨이에게 요청을 처리해달라고 할 수 있음.
  - 게이트웨이는 그에 응답.

> 게이트웨이는 요청을 받고 응답을 보내는 포털 같이 동작하는데, 동적인 콘텐츠를 생성하거나 데이터베이스에 질의를 보낼 수 있음.

- 게이트웨이는 `HTTP` 트래픽을 다른 프로토콜로 자동 변환하여 `HTTP` 클라이언트가 다른 프로토콜을 알 필요 없이 서버에 접속할 수 있게 하기도 함.
- 게이트웨이의 예
  1. 게이트웨이는 `FTP` `URL`을 가리키는 `HTTP` 요청을 받고, `FTP` 커넥션을 맺은 후 `FTP` 서버에 적절한 명령을 전송함. 이에 클라이언트는 적절한 `HTTP` 헤더와 함께 `HTTP`를 통해서 문서를 받음.
  2. 게이트웨이는 암호화된 웹 요청을 `SSL`을 통해 받고, 요청을 해독해서 일반 `HTTP` 요청을 목적지 서버로 전달함. 이런 보안 가속기는 원 서버에 고성능 암호화 기능을 제공할 목적으로 웹 서버의 바로 앞단에 위치시킬 수 있음.
  3. 게이트웨이는 애플리케이션 서버 게이트웨이 `API`를 통해서 `HTTP` 클라이언트를 서버 측 애플리케이션 프로그램에 연결. 웹에서 물건을 사거나 일기예보를 보거나 주식 시세를 볼 때, 사실은 애플리케이션 서버 게이트웨이를 방문하는 것.

### 클라이언트 측 게이트웨이와 서버 측 게이트웨이

- 웹 게이트웨이는 한 쪽에서는 `HTTP`로 통신하고, 다른 한 쪽에서는 `HTTP`가 아닌 다른 프로토콜로 통신.
- 게이트웨이는 클라이언트 측 프로토콜과 서버 측 프로토콜을 빗금(`/`)으로 구분해 기술.
  - 게이트웨이가 `HTTP` 클라이언트와 `NNTP` 뉴스 서버 사이에 있으면 `HTTP/NNTP` 게이트웨이.
- 서버 측 게이트웨이: 클라이언트와 `HTTP`로 통신하고, 서버와는 외래 프로토콜로 통신.
- 클라이언트 측 게이트웨이: 클라이언트와 외래 프로토콜로 통신하고, 서버와는 `HTTP`로 통신.

---

## 프로토콜 게이트웨이

- 프록시에 트래픽을 바로 보내는 것과 같이 게이트웨이에도 `HTTP` 트래픽을 바로 보낼 수 있음.
  - 브라우저에 명시적으로 게이트웨이를 설정하여 자연스럽게 트래픽이 게이트웨이를 거쳐 가게 하거나, 게이트웨이를 대리 서버(리버스 프록시)로 설정 가능.

### `HTTP/*`: 서버 측 웹 게이트웨이

- 서버 측 게이트웨이는 클라이언트로부터 `HTTP` 요청이 원 서버 영역으로 들어오는 시점에 클라이언트 측의 `HTTP` 요청을 외래 프로토콜로 전환.
- 게이트웨이의 역할 예시
  - `USER`와 `PASS` 명령을 보내서 서버에 로그인.
  - 서버에 적절한 디렉터리로 변경하기 위해 `CWD` 명령을 내림.
  - 다운로드 형식을 `ASCII`로 설정.
  - `MDTM`으로 문서의 최근 수정 시간을 가져옴.
  - `PASV`로 서버에게 수동형 데이터 검색을 하겠다고 말함.
  - `RETR`로 객체를 검색.
  - 제어 채널에서 반환된 포트로 `FTP` 서버에 데이터 커넥션을 맺음.
    - 데이터 채널이 열리는 대로, 객체가 게이트웨이로 전송.
      > 게이트웨이는 객체를 받는 대로 `HTTP` 응답에 실어서 클라이언트에 전송.

### `HTTP/HTTPS`: 서버 측 보안 게이트웨이

- 기업 내부의 모든 웹 요청을 암호화함으로써 개인 정보 보호와 보안을 제공하는데 게이트웨이 사용 가능.
- 클라이언트는 일반 `HTTP`를 사용하여 웹을 탐색할 수 있지만, 게이트웨이는 자동으로 모든 세션을 암호화.

### `HTTPS/HTTP`: 클라이언트 측 보안 가속 게이트웨이

- `HTTPS/HTTP` 게이트웨이는 보안 가속기로 유명함.
- 웹 서버의 앞단에 위치하여 보이지 않는 인터셉트 게이트웨이나 리버스 프록시 역할 수행.
- 보안 `HTTPS` 트래픽을 받아서 복호화하고, 웹 서버로 보낼 일반 `HTTP` 요청을 만듬.
- 이런 게이트웨이는 원 서버보다 더욱 효율적으로 보안 트래픽을 복호화하는 암호화 하드웨어를 내장해서 원 서버의 부하를 줄여주기도 함.
  > 이는 게이트웨이와 원 서버 간의 암호화하지 않은 트래픽을 전송하기 때문에, 게이트웨이와 원 서버 간에 있는 네트워크가 안전한지 확인을 확실히 하고 사용해야 함.

---

## 리소스 게이트웨이

- 애플리케이션 서버: 게이트웨이의 가장 일반적인 형태.
  - 목적지 서버와 게이트웨이를 한 개의 서버로 결합.
  - `HTTP`를 통해서 클라이언트와 통신하고 서버 측에 있는 애플리케이션 프로그램에 연결하는 서버 측 게이트웨이.
- 클라이언트가 `HTTP`를 사용하여 애플리케이션 서버로 연결하지만, 서버로부터 파일이 전송되는 대신에 애플리케이션 서버는 게이트웨이의 애플리케이션 프로그래밍 인터페이스(`API`, Application Programming Interface)를 통해서 요청을 서버에 동작하고 있는 애플리케이션에 전달.
- 공용 게이트웨이 인터페이스(`CGI`, Common Gateway Interface): 애플리케이션 게이트웨이에서 유명했던 최초의 `API`.
  - 특정 `URL`에 대한 `HTTP` 요청에 따라 프로그램을 실행하고, 프로그램의 출력을 수집하고, `HTTP` 응답으로 회신하는데 웹 서버가 사용하는 표준화된 인터페이스의 집합.
  - 초기 웹 서버는 제작이 꽤 단순했으며, 게이트웨이의 인터페이스를 구현하는 단순한 접근 방식은 오늘날까지 이어지고 있음.
- 게이트웨이를 통해야 받을 수 있는 리소스 요청이 들어오면, 서버는 헬퍼 애플리케이션을 생성하여 요청을 처리.
  - 헬퍼 애플리케이션은 필요한 데이터를 전달 받음.
    - 전달받은 데이터는 요청 전체이거나 사용자가 데이터베이스에서 실행시키려는 질의같은 것.(`URL`의 질의 문자열(`query string`)을 통해 전송.)
  - 그 다음, 바로 클라이언트로 전달할 응답이나 응답 데이터를 서버에 반환.
  - 서버와 게이트웨이는 별개의 애플리케이션이기 때문에 각각 가지고 있는 책임은 분명히 나뉘어 있음.

> 이 단순한 프로토콜은 가장 오래되고 널리 쓰이는 서버 확장 인터페이스인 `CGI`.

### 공용 게이트웨이 인터페이스(`CGI`, Common Gateway Interface)

- `CGI`는 최초의 서버 확장이자 지금까지도 널리 쓰이는 서버 확장.
  - 동적인 `HTML`, 신용카드 처리, 데이터베이스 질의 등을 제공하는 데 사용.
- `CGI` 애플리케이션이 서버와 분리되면서 펄(`Perl`), `Tcl`, `C`, 다양한 셸 언어를 포함하여 수 많은 언어로 구현할 수 있게 됨.
  - 또한 단순하므로 거의 모든 `HTTP`가 지원.
- `CGI`가 내부에서 어떤 처리를 하는 지는 사용자에게 보이지 않음.
  - 사용자의 시각에서는 `CGI`가 내부적으로 일반적인 요청을 만드는 것일 뿐.
- 서버와 `CGI` 애플리케이션 간에 진행되는 처리 단계를 감춤.
  - 클라이언트가 `CGI` 애플리케이션이 무언가를 하고 있다는 것을 알 수 있는 유일한 단서는 `URL`에 있는 `cgi`, `?` 같은 것들 뿐.
- `CGI`는 거의 모든 리소스 형식과 서버의 접점에 있으면서 필요에 따라 어떤 변형이든 처리해내는 단순한 기능을 제공.
  - 인터페이스는 문제가 많은 확장으로부터 서버를 보호한다는 점에서 훌륭.
- 이런 분리 때문에 성능에 관련한 비용이 발생.
  - 모든 `CGI` 요청마다 새로운 프로세스를 만드는 데 따르는 부하, `CGI`를 사용하는 서버의 성능을 제한, 서버 장비에 부담.
    > 이 문제를 피하고자 `Fast CGI`가 개발되어 요청마다 새로운 프로세스를 만들고 제거하면서 생기는 성능 저하 문제 해결.

### 서버 확장 `API`

- `CGI` 프로토콜은 구동 중인 `HTTP` 서버에 외부 인터프리터가 쉽게 접속할 수 있게 해줌.
- 서버 자체의 동작을 바꾸고 싶거나 서버의 처리 능력을 최고치로 끌어 올리고자 할 때의 필요성에 의해 자신의 모듈을 `HTTP` 와 직접 연결할 수 있는 인터페이스인 서버 확장 `API`를 제공.
- 확장 `API`: 프로그래머가 자신의 코드를 서버에 연결하거나 서버의 컴포넌트를 자신이 만든 것으로 교체해버릴 수 있게 함.
  - 확장은 서버 자체의 아키텍처에 의존하기 때문에, 대부분 한 가지 서버 형식으로 특화.
- 서버 확장의 예
  - 프론트 페이지(`FrontPage`) 제작자가 웹 출판 서비스를 하게 지원해주는 마이크로소프트의 프론트 페이지 서버 확장(`FPSE`, FrontPage Server Exntesion).
  - `FPSE`는 프론트페이지 클라이언트로부터 전송되는 원격 프로시져 호출(`RPC`, Remote Procedure Call) 명령을 인식 가능.
  - 이 명령은 `HTTP`(특히, `POST` 메서드)에 편승하여 옴.

---

## 애플리케이션 인터페이스와 웹 서비스

- `HTTP`가 애플리케이션을 연결하면서 데이터를 교환하려는 두 애플리케이션 사이에서 프로토콜 인터페이스를 맞추는 이슈가 발생.
- 애플리케이션이 상호 운용을 하다보면 `HTTP` 헤더로는 표현하기 힘든 복잡한 정보를 교환해야 할 수도 있음.
- 인터넷 커뮤니티는 각 웹 애플리케이션이 서로 통신하는데 사용할 표준과 프로토콜 집합을 개발.
  - 이러한 표준은, 원래 웹 서비스가 독립형 웹 서비스(빌딩 블록) 그 자체를 의미함에도 불구하고, 그냥 그대로 웹 서비스라고 불리게 됨.
  - 웹 서비스: 애플리케이션이 정보를 공유하는데 사용하는 새로운 메커니즘을 의미.
    > 웹 서비스는 `HTTP` 같은 표준 웹 기술 위에서 개발.
- 웹 서비스는 `SOAP`를 통해 `XML`을 사용하여 정보를 교환.
- `XML`(eXtensible Markup Language): 데이터 객체를 담는 데이터를 생성하고 해석하는 방식 제공.
- `SOAP`(Simple Object Access Protocol): `HTTP` 메세지에 `XML` 데이터를 담는 방식에 관한 표준.

---

## 터널

- 웹 터널: `HTTP` 프로토콜을 지원하지 않는 애플리케이션에 `HTTP` 프로토콜을 사용해 접근하는 방법을 제공.
- 웹 터널을 사용하면 `HTTP` 커넥션을 통해서 `HTTP`가 아닌 트래픽을 전송할 수 있고, 다른 프로토콜을 `HTTP` 위에 올릴 수 있음.

> 웹 터널을 사용하는 일반적인 이유: `HTTP` 커넥션 안에 `HTTP`가 아닌 트래픽을 얹기 위해.  
> 따라서 웹 터널을 사용하면 웹 트래픽만을 허락하는 방화벽이 있더라도 `HTTP`가 아닌 트래픽 전송 가능.

### `CONNECT`로 `HTTP` 터널 커넥션 맺기

- 웹 터널은 `HTTP`의 `CONNECT` 메서드를 사용하여 커넥션을 맺음.
  - `CONNECT` 프로토콜은 `HTTP/1.1` 명세에 자세히 나와 있지는 않지만, 많이 구현하는 프로토콜.
- `CONNECT` 메서드는 터널 게이트웨이가 임의의 목적 서버와 포트에 `TCP` 커넥션을 맺고 클라이언트와 서버 간에 오는 데이터를 무조건 전달하기를 요청.

#### `CONNECT` 요청

- 문법은 시작줄을 제외하고는 다른 `HTTP` 메서드와 같음.
- 요청 `URI`는 호스트 명이 대신하며, 콜론에 이어 포트를 기술.

  ```shell
  CONNECT home.netscape.com:443 HTTP/1.0
  User-Agent: Mozilla/4.0
  ```

- 시작줄 다음에는 다른 `HTTP` 메세지와 같이 추가적인 `HTTP` 요청 헤더 필드가 있거나 없음.
- 보통 각 행은 `CRLF`로, 헤더 목록의 끝은 빈 줄의 `CRLF`로 끝남.

#### `CONNECT` 응답

- 클라이언트는 요청을 전송한 다음, 게이트웨이의 응답을 기다림.
- 일반 `HTTP` 메세지와 같이 `200` 응답 코드는 성공을 뜻함.
  - 편의상 응답에 있는 사유 구절은 `Connection Established`로 기술.
- 일반적인 `HTTP` 응답과는 달리 `Content-Type` 헤더를 포함할 필요는 없음.
  - 메세지를 전달하는 대신 바이트를 그대로 전달하기 때문에 콘텐츠의 형식을 기술할 필요가 없음.

### 데이터 터널링, 시간, 커넥션 관리

- 터널을 통해 전달되는 데이터는 게이트웨이에서 볼 수 없어서, 게이트웨이는 패킷의 순서나 흐름에 대한 어떤 가정도 불가능.
  - 터널이 일단 연결되면, 데이터는 언제 어디로든 흘러가버릴 수 있음.
- 클라이언트는 성능을 높이기 위해 `CONNECT` 요청을 보낸 다음, 응답을 받기 전에 터널 데이터를 전송 가능.
  - 서버에 데이터를 더 빨리 보내는 방법이지만, 게이트웨이가 요청에 이어서 데이터를 적절하기 처리할 수 있어야 함을 전제로 함.
    - 게이트웨이는 네트워크 `I/O` 요청이 헤더 데이터만을 반환해줄 거라고 가정할 수 없어서, 커넥션이 맺어지는 대로 헤더를 포함해서 읽어들인 모든 데이터를 서버에 전송해야 함.
    - 요청 후 터널을 통해 데이터를 전송한 클라이언트는 인증 요구(authentication challenge)나 `200` 외의 응답이 왔을 때 요청 데이터를 다시 보낼 준비가 되어 있어야 함.
- 터널의 끝단 어느 부분이든 커넥션이 끊어지면, 그 끊어진 곳으로부터 온 데이터는 반대편으로 전달.
- 그 다음 커넥션이 끊어졌던 터널의 끝단 반대편의 커넥션도 프록시에 의해서 끊어짐.
  - 커넥션이 끊긴 한 쪽에 아직 전송하지 않은 데이터는 버려짐.

### `SSL` 터널링

- 웹 터널은 원래 방화벽을 통해서 암호화된 `SSL` 트래픽을 전달하려고 개발.
- `SSL`과 같이 암호화된 프로토콜은 정보가 암호화되어 있기 때문에 낡은 방식의 프록시에선 처리 불가.

> 터널을 사용하면 `SSL` 트래픽을 `HTTP` 커넥션으로 전송하여 `80` 포트의 `HTTP` 만을 허용하는 방화벽을 통과시킬 수 있음.

- `SSL` 트래픽이 기존 프록시 방화벽을 통과할 수 있도록 `HTTP`에 터널링 기능이 추가.
  - 이 터널링 기능은 `HTTP` 메세지에 암호화된 날 데이터를 담고 일반 `HTTP` 채널을 통해 전송.
- 터널은 `HTTP`가 아닌 트래픽이 포트를 제한하는 방화벽을 통과할 수 있게 해줌.
  - 이는 보안 `SSL` 트래픽이 방화벽을 통과하는 데 유용하게 사용.
  - 악의적인 트래픽이 사내로 유입되는 경로가 될 수 있음.

### `SSL` 터널링 vs `HTTP/HTTPS` 게이트웨이

- `HTTPS` 프로토콜(`SSL` 상의 `HTTP`)은 다른 프로토콜과 같은 방식으로 게이트웨이를 통과 가능.
  - 원격 `HTTTPS` 서버와 `SSL` 세션을 시작하는 게이트웨이(클라이언트 대신)를 두고 클라이언트 측의 `HTTPS` 트랜잭션을 수행하는 방식.
  - 응답은 프록시가 받아서 복호화하고 난 후에, `HTTP`를 통해 클라이언트로 전송.
    > 게이트웨이가 `FTP`를 처리하는 방식과 같음.
  - 위 접근 방식의 단점
    1. 클라이언트-게이트웨이 사이에는 보안이 적용되지 않은 일반 `HTTP` 커넥션이 맺어져 있음.
    2. 프록시가 인증을 담당하고 있기 때문에, 클라이언트는 원격 서버에 `SSL` 클라이언트 인증(`X509` 인증서 기반의 인증) 불가.
    3. 게이트웨이는 `SSL`을 완벽히 지원해야 함.
  - 이 상황에서 `SSL` 터널링을 사용하면, 프록시에 `SSL`을 구현할 필요가 없음.
- `SSL` 세션은 클라이언트가 생성한 요청과 목적지(보안이 적용된) 웹 서버 간에 생성.
- 프록시 서버는 트랜잭션의 보안에는 관여하지 않고 암호화된 데이터를 그대로 터널링할 뿐.

### 터널 인증

- `HTTP`의 다른 기능들은 터널과 함께 적절히 사용 가능.
- 특히, 프록시 인증 기능은 클라이언트가 터널을 사용할 수 있는 권한을 검사하는 용도로 터널에서 사용 가능.

### 터널 보안에 대한 고려사항들

- 터널 게이트웨이는 통신하고 있는 프로토콜이 터널을 올바른 용도로 사용하고 있는지 검증할 방법이 없음.
  - 악의적인 목적으로 사용될 가능성.
- 터널의 오용을 최소화하기 위해서, 게이트웨이는 `HTTPS` 전용 포트인 `443` 같이 잘 알려진 특정 포트만을 터널링할 수 있게 허용해야 함.

---

## 릴레이

- `HTTP` 릴레이: `HTTP` 명세를 완전히 준수하지는 않는 간단한 `HTTP` 프록시.
  - 릴레이는 커넥션을 맺기 위한 `HTTP` 통신을 한 다음, 바이트를 맹목적으로 전달.
- `HTTP`는 복잡하기에, 모든 헤더와 메서드 로직을 수행하지 않고 맹목적으로 트래픽을 전달하는 간단한 프록시를 구현하는 방식이 유용할 때가 있음.
  - 데이터를 맹목적으로 전달하도록 구현하기는 쉽기 떄문에, 단순 필터링이나 진단 혹은 콘텐츠 변환을 하는데 사용되기도 함.
    > 이는 잠재적으로 심각한 상호 운용 문제를 가지고 있기 때문에 주의해서 배포.
- 단순 맹목적 릴레이를 구현하는데 가장 큰 문제는, 맹목적 릴레이가 `Connection` 헤더를 제대로 처리하지 못해서 `keep-alive` 커넥션이 행(`hang`)에 걸리는 것.
  - 이러한 위험을 예방하기 위해 릴레이를 조금이나마 똑똑하게 만드는 방법이 있지만, 프록시의 단순함 이면에는 상호 운용과 관련한 문제가 발생할 위험이 있음.

> 특정 목적을 위해서 단순한 `HTTP` 릴레이를 구축하는 중이라면, 그것을 어떻게 사용할지 신중하게 고민해야 함.  
> 여러 문제를 예방하기 위해서, `HTTP`를 제대로 준수하는 프록시를 사용하는 게 좋음.
