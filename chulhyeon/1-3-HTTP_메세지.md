# `HTTP` 메세지

## 메세지의 흐름

- `HTTP` 메세지: `HTTP` 애플리케이션 간에 주고 받은 데이터의 블록.
  - 메세지의 내용과 의미를 설명하는 텍스트 메타 정보로 시작, 이후 선택적으로 데이터 첨부.
  - 클라이언트, 서버, 프록시 사이를 흐름.
  - 메세지의 방향: 인바운드, 아웃바운드, 업스트림, 다운스트림.

### 메세지는 원 서버 방향을 인바운드로 하여 송신

- 인바운드, 아웃바운드: `HTTP`에서 트랜잭션 방향을 표현하기 위해 사용.
- 메세지가 원 서버로 향하는 것 = 인바운드로 이동.
- 모든 처리가 끝난 뒤 메세지가 사용자 에이전트로 돌아오는 것 = 아웃바운드로 이동.

### 다운스트림으로 흐르는 메세지

- 요청, 응답 메세지 관계 없이 다운스트림으로 흐름.
- 메세지의 발송자는 수신자의 업스트림.

> 시작점이 업스트림, 도착점이 다운스트림.

---

## 메세지의 각 부분

- 각 메세지는 클라이언트로부터의 요청이나 서버로부터의 응답 중 하나를 포함.
- 메세지는 세 부분(시작줄, 헤더 블록, 본문)으로 구성.
  - 시작줄: 어떤 메세지인지 서술.
  - 헤더 블록: 속성.
  - 본문: 데이터(없을 수 있음).
- 시작줄과 헤더는 줄 단위로 분리된 아스키 문자열이며, 각 줄은 캐리지 리턴(ASCII 13)과 개행 문자(ASCII 10)로 구성된 두 글자의 줄바꿈 문자열(`CRLF`)로 끝남.
  - `HTTP` 명세에 따른다면 줄바꿈 문자열은 `CRLF`이지만, 견고한 애플리케이션이라면 그냥 개행 문자도 받아들일 수 있어야 함.
  - 레거시 `HTTP` 애플리케이션들 중에서는 캐리지 리턴과 개행 문자 모두를 항상 전송하지 않을 수도 있음.
- 엔터티 본문, 메세지 본문은 단순히 선택적인 데이터 덩어리.
  - 텍스트나 이진 데이터를 포함할 수도, 비어있을 수도 있음.

> Q. 엔터티 본문과 메세지 본문의 차이점?

### 메세지 문법

- 모든 `HTTP` 메세지는 요청 메세지나 응답 메세지로 분류.
- 요청 메세지는 웹 서버에 어떤 동작을 요구.

  - 형식

    ```
    <메서드> <요청 URL> <버전>
    <헤더>

    <엔터티 본문>
    ```

- 응답 메세지는 요청의 결과를 클라이언트에게 돌려줌.

  - 형식

    ```
    <버전> <상태 코드> <사유 구절>
    <헤더>

    <엔터티 본문>
    ```

#### 메서드

- 클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작.

#### 요청 `URL`

- 요청 대상이 되는 리소스를 지칭하는 완전한 `URL` 혹은 `URL`의 경로 구성 요소.
  > Q. "클라이언트가 서버와 직접 대화 하고 있고 경로 구성 요소가 리소스를 가리키는 절대 경로이기만 하면 대체로 문제가 없다. 서버는 `URL`에서 생략된 호스트/포트가 자신을 가리키는 것으로 간주할 것"의 뜻.

#### 버전

- 메세지에서 사용 중인 `HTTP의 버전.
- 형식
  ```
  HTTP/<메이저>.<마이너>
  ```
- 메이저와 마이너는 모두 정수.

#### 상태 코드

- 요청 중에 무엇이 일어났는지 설명하는 세 자리의 숫자.
- 각 코드의 첫 번째 자릿 수는 상태의 일반적인 분류(`성공`, `에러` 등)을 나타냄.

#### 사유 구절(reason-phrase)

- 숫자로된 상태 코드의 의미를 사람이 이해할 수 있게 설명해주는 짧은 문구.
- 상태 코드 이후부터 줄바꿈 문자열까지가 사유 구절.
- 오로지 사람에게 읽히기 위한 목적으로만 존재하는 것.
  > Q. 사람에게 읽히기 위한 목적이라면 실제로 전송되는 데이터인지 아니면 클라이언트(브라우저) 내부적으로 처리하는지?

#### 헤더들

- 이름, 콜론(`:`), 선택적인 공백, `CRLF`가 순서대로 나타나는 0개 이상의 헤더들.
- 헤더의 목록은 빈 줄(`CRLF`)로 끝나 헤더 목록의 끝과 엔터티 본문의 시작을 표시.
- `HTTP/1.1`과 같은 몇몇 버전의 `HTTP`는 요청이나 응답에 어떤 특정 헤더가 포함되어야만 유효한 것으로 간주.

#### 엔터티 본문

- 임의의 데이터 블록을 포함.
- 모든 메세지가 엔터티 본문을 갖는 것은 아니므로, 그냥 `CRLF`로 끝나는 메세지가 있을 수 있음.
- 헤더나 엔터티 본문이 없더라도 `HTTP` 헤더의 집합은 항상 빈 줄(그냥 `CRLF`)로 끝나야 함.
- 하지만 많은 클라이언트와 서버가 마지막 `CRLF`를 빠뜨리므로, 규칙을 잘 지키지 않는 구현체와의 호환을 위해 클라이언트와 서버는 마지막 `CRLF` 없이 끝나는 메세지도 받아들일 수 있어야 함.

### 시작줄

- 모든 `HTTP` 메세지는 시작줄로 시작.

#### 요청줄(요청 메세지의 시작줄)

- 서버에서 어떤 동작이 일어나야 하는지 설명해주는 메서드와 그 동작에 대한 대상을 지칭하는 요청 `URL`이 포함.
- 클라이언트가 어떤 `HTTP` 버전으로 말하고 있는지 서버에게 알려주는 `HTTP` 버전도 포함.
- 이 모든 필드는 공백으로 구분.

#### 응답줄(응답 메세지의 시작줄)

- 응답 메세지에서 쓰인 `HTTP` 버전 포함.
- 숫자로된 상태 코드, 수행 상태에 대해 설명해주는 텍스트로 된 사유 구절도 포함.
- 이 모든 필드는 공백으로 구분.

#### 메서드

- 서버에게 무엇을 해야하는지 말해줌.
- `HTTP` 명세는 공통 요청 메서드의 집합을 정의.
- 많이 쓰이는 `HTTP` 메서드
  |메서드|설명|메세지 본문이 있는가?|
  |:-:|:-:|:-:|
  |`GET`|어떤 문서를 가져옴.|`X`|
  |`HEAD`|어떤 문서의 헤더만 가져옴.|`X`|
  |`POST`|서버가 처리해야 할 데이터 보냄.|`O`|
  |`PUT`|서버에 요청 메세지의 본문을 저장.|`O`|
  |`TRACE`|메세지가 프록시를 거쳐 서버에 도달하는 과정을 추적.|`X`|
  |`OPTIONS`|서버가 어떤 메서드를 수행할 수 있는지 확인.|`X`|
  |`DELETE`|서버에서 문서를 제거.|`X`|
- 모든 서버가 위 메서드들을 구현한 것은 아님.
- `HTTP`는 쉽게 확장할 수 있도록 설계되었기 때문에, 다른 서버는 그들만의 메서드를 추가로 구현했을 수 있음.
  - 추가 메서드 확장 메서드라고 불림.

#### 상태 코드

- 클라이언트에게 무엇이 일어났는지 말해줌.
- 응답의 시작줄에 위치.
- 숫자로된 코드와 문자열로 되어 있어서 사람이 이해하기 쉬운 메세지 두 형태로 모두 반환.
  - 사유 구절(사람), 숫자 코드(프로그램).
    |전체범위|정의된 범위|분류|
    |:-:|:-:|:-:|
    |`100`-`199`|`100`-`101`|정보|
    |`200`-`299`|`200`-`206`|성공|
    |`300`-`399`|`300`-`305`|리다이렉션|
    |`400`-`499`|`400`-`415`|클라이언트 에러|
    |`500`-`599`|`500`-`505`|서버 에러|

#### 사유 구절

- 응답 시작줄의 마지막 요소.
- 상태 코드에 대한 글로 된 설명 제공.
- 사유 구절은 상태 코드와 일대일로 대응.
- `HTTP` 명세는 사유 구절에 대한 엄격한 규칙은 제공하지 않음.

#### 버전 번호

- `HTTP/x.y` 형식으로 요청과 응답 메세지 양쪽에 모두 기술.
- `HTTP` 애플리케이션들이 자신이 따르는 프로토콜의 버전을 상대방에게 말해주기 위한 수단.
- `HTTP`로 대화하는 애플리케이션들에게 대화 상대의 능력과 메세지의 형식에 대한 단서를 제공해주기 위한 것.
- 버전 번호는 어떤 애플리케이션이 지원하는 가장 높은 `HTTP` 버전을 가리킴.
  - 이는 때때로 혼란을 유발함.
  - 응답 프로토콜 버전이 `HTTP/1.1`이라는 것은 응답을 보낸 애플리케이션이 `HTTP/1.1`까지 이해할 수 있음을 의미.
- 버전 번호는 분수로 다루어지지 않음.
  - 대/소를 비교하기 위해서 각 숫자는 반드시 따로따로 비교해야 함.

### 헤더

- 시작줄 다음에는 0개 이상의 `HTTP` 헤더가 옴.
- `HTTP` 헤더 필드는 요청과 응답 메세지에 추가 정보를 더함.
  - 이름/값 쌍의 목록.

#### 헤더 분류

- `HTTP` 헤더 명세는 여러 헤더 필드를 정의.
- 애플리케이션은 자유롭게 자신만의 헤더를 만들어낼 수 있음.
- 일반 헤더: 요청과 응답 양쪽에 모두 나타날 수 있음.
- 요청 헤더: 요청에 대한 부가 정보 제공.
- 응답 헤더: 응답에 대한 부가 정보 제공.
- `Entity` 헤더: 본문 크기와 콘텐츠, 혹은 리소스 그 자체를 서술.
- 확장 헤더: 명세에 정의되지 않은 새로운 헤더.

> 각 헤더는 이름, 쉼표, 공백(없어도 됨), 필드 값, `CRLF`가 순서대로 옴.

#### 헤더를 여러 줄로 나누기

- 긴 헤더 줄은 여러 줄로 쪼개서 더 읽기 좋게 만들 수 있는데, 추가 줄 앞에는 최소 하나의 스페이스 혹은 탭 문자가 와야 함.
- `Ex)`
  ```
  HTTP/1.0 200 OK
  Content-Type: image/gif
  Content-Length: 8572
  Server: Test Server
    Version 1.0
  ```

### 엔터티 본문

- `HTTP` 메세지는 이미지, 비디오, `HTML` 문서, 소프트웨어 애플리케이션, 신용카드 트랜잭션, 전자우편 등 여러 종류의 디지털 데이터를 실어 나를 수 있음.

> `HTTP`가 수송하도록 설계 된 `HTTP` 메세지의 화물.

### 버전 `0.9` 메세지

- 요청은 그저 메서드와 요청 `URL`을 갖고 있으며, 응답은 엔터티로만 구성.
- 버전 정보, 상태 코드나 사유 구절, 헤더도 포함되어 있지 않음.
- 지나칠 정도의 단숨함 때문에 다양한 상황에 대응할 수 없으며, `HTTP`의 기능들과 애플리케이션들도 대부분 구현할 수 없음.
- 여전히 `HTTP/0.9`를 사용하는 클라이언트, 서버, 기타 애플리케이션 들이 있을 수 있음.

---

## 메서드

- 모든 서버가 모든 메서드를 구현하지 않음.
- 비록 서버가 모든 메서드를 구현하지 않았다 하더라도 메서드는 대부분 제한적으로 사용될 것.

### 안전한 메서드(`Safe Method`)

- `HTTP`는 안전한 메서드라 불리는 메서드의 집합을 정의.
- `GET`, `HEAD` 메서드는 요청의 결과로 서버에 어떤 작용도 없기 떄문에 안전함.
  - `HTTP` 요청의 결과로 서버에서 일어나는 일은 아무 것도 없다는 의미.
- 안전한 메서드가 서버에 작용을 유발하지 않는다는 보장은 개발자에게 달림.
- 안전한 메서드의 목적은, 서버에 어떤 영향을 줄 수 있는 안전하지 않은 메서드가 사용될 때 그 사실을 알려주는 `HTTP` 애플리케이션을 만들 수 있도록 하는 것에 있음.

### `GET`

- 가장 흔히 쓰이는 메서드.
- 주로 서버에게 리소스를 달라고 요청하기 위해 사용.

### `HEAD`

- `GET`처럼 행동하지만, 서버는 응답으로 헤더만을 돌려줌.
  - 엔터티 본문은 결코 반환되지 않음.
  - 클라이언트가 리소스를 실제로 가져올 필요 없이 헤더만을 조사할 수 있도록 해줌.
- 효과
  - 리소스를 가져오지 않고도 그에 대해 무엇인가(타입)를 알아냄.
  - 응답의 상태 코드를 통해, 개체가 존재하는지 확인.
  - 헤더를 확인하여 리소스가 변경되었는지 검사.
- 서버 개발자들은 반드시 반환되는 헤더가 `GET`으로 얻는 것과 정확히 일치함을 보장해야 함.

### `PUT`

- 서버에 문서를 쓰기 위해 쓰이는 메서드.
- 서버가 요청의 본문을 가지고 요청 `URL`의 이름대로 새 문서를 만들거나, 이미 `URL`이 존재한다면 본문을 사용해서 교체하는 것.

> 서버에 있는 리소스에 데이터를 입력하기 위함.

### `POST`

- 서버에 입력 데이터를 전송하기 위해 설계.
- `HTML` 폼을 지원하기 위해 흔히 사용.
- 채워진 폼에 담긴 데이터는 서버로 전송되며, 서버는 이를 모아서 필요로 하는 곳에 보냄.

> 서버에 데이터를 보내기 위함.

### `TRACE`

- 클라이언트가 어떤 요청을 할 때, 그 요청은 방화벽, 프록시, 게이트웨이 등의 애플리케이션을 통과할 수 있는데, `TRACE` 메서드는 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려줌.
- 목적지 서버에 루프백(`loopback`) 진단을 시작함.
  - 요청 전송의 마지막 단계에 있는 서버는 자신이 받은 요청 메세지를 본문에 넣어 `TRACE` 응답에게 되돌려 줌.
  - 클라이언트는 자신과 목적지 서버 사이에 있는 모든 `HTTP` 애플리케이션의 요청/응답 연쇄를 따라가면서 자신이 보낸 메세지가 망가졌거나 수정되었는지, 만약 그렇다면 어떻게 변경되었는지 확인 가능.
- `TRACE` 메서드는 주로 진단을 위해 사용.
  - 프록시나 다른 애플리케이션들이 요청에 어떤 영향을 미치는지 확인해보고자 할 때도 좋은 도구.
- 중간 애플리케이션이 여러 다른 종류의 요청들을 일관되게 다룬다고 가정하는 문제가 있음.
  - 메서드를 구별하는 메커니즘을 제공하지 않음.
  - `TRACE` 요청의 처리는 일반적으로 중간 애플리케이션이 결정을 내림.
- 어떠한 엔터티 본문도 보낼 수 없으며, `TRACE` 응답의 엔터티 본문에는 서버가 받은 요청이 그대로 들어있음.

### `OPTIONS`

- 웹 서버에게 여러 가지 종류의 지원 범위에 대해 물어봄.
- 서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지 물어볼 수 있음.
- 여러 리소스에 대해 실제로 접근하지 않고도 그것들을 어떻게 접근하는 것이 최선인지 확인할 수 있는 수단을 클라이언트에 제공.

### `DELETE`

- 서버에게 요청 `URL`로 지젛안 리소스를 삭제할 것을 요청.

### 확장 메서드

- 확장해도 문제가 없도록 설계되어 있으므로, 새로 기능을 추가해도 과거에 구현된 소프트웨어들의 오동작을 유발하지 않음.
- 모든 확장 메서드가 형식을 갖춘 명세로 정의된 것은 아님.
- 확장 메서드에 대해 관용적인 것이 좋음.

---

## 상태 코드

- 상태 코드는 크게 다섯 가지로 나뉨.
- 상태 코드는 클라이언트에게 그들의 트랜잭션을 이해할 수 있는 쉬운 방법을 제공.

### `100`-`199`: 정보성 상태 코드

- `HTTP/1.1`에 도입되어 현재까지 가치에 대해 논란이 되고 있음.

| 상태 코드 |      사유 구절      |                                            의미                                             |
| :-------: | :-----------------: | :-----------------------------------------------------------------------------------------: |
|   `100`   |      Continue       | 요청의 시작 부분 일부가 받아들여졌으며, 클라이언트는 나머지를 계속 이어서 보내야 함을 의미. |
|   `101`   | Switching Protocols |    클라이언트가 `Upgrade` 헤더에 나열한 것 중 하나로 서버가 프로토콜을 바꾸었음을 의미.     |

- `100` Continue는 `HTTP` 클라이언트 애플리케이션이 서버에 엔터티 본문을 전송하기 전에 그 엔터티 본문을 서버가 받아들일 것인지 확인하려고 할 때, 그 확인 작업을 최적화하기 위한 의도로 도입.

#### 클라이언트와 `100` Continue

#### 서버와 `100` Continue

#### 프록시와 `100` Continue

### `200`-`299`: 성공 상태 코드

| 상태 코드 |           사유 구절           |                                                                                                                    의미                                                                                                                    |
| :-------: | :---------------------------: | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
|   `200`   |              OK               |                                                                                            요청은 정상이고, 엔터티 본문은 요청된 리소스를 포함.                                                                                            |
|   `201`   |            Created            | 서버 개체를 생성하라는 요청을 위한 것. 생성된 리소스에 대한 구체적인 참조가 담긴 `Location` 헤더와 함께 그 리소스를 참조할 수 있는 여러 `URL`을 본문에 포함하여 응답하여야 함. 서버는 상태 코드를 보내기에 앞서 반드시 객체를 생성해야 함. |
|   `202`   |           Accepted            |           요청은 받아들여 졌으나 서버는 아직 그에 대한 어떤 동작도 수행하지 않음. 요청이 받아들이기에 적법해 보인다는 의미. 요청에 대한 상태와 가급적이면 요청의 처리가 언제 완료될 것인지에 대한 추정을 포함하여 응답하여야 함.           |
|   `203`   | Non-Authoritative Information |                                                                               엔터티 헤더에 들어있는 정보가 원래 서버가 아닌 리소스의 사본에서 옴.(선택사항)                                                                               |
|   `204`   |          No Content           |                                                        응답 메세지는 헤더와 상태줄을 포함하지만 엔터티 본문은 포함하지 않음. 주로 새 문서로 이동시키지 않고 갱신하고자 할 때 사용.                                                         |
|   `205`   |         Reset Content         |                                                                                브라우저에게 현재 페이지에 있는 `HTML` 폼에 채워진 모든 값을 비우라고 말함.                                                                                 |
|   `206`   |        Partial Contnet        |                                           부분 혹은 범위 요청이 성공. `Content-Rage`와 `Date` 헤더를 반드시 포함하여야 하며, `Etag`와 `Content-Location` 중 하나의 헤더도 반드시 포함하여야 함.                                            |

### `300`-`399`: 리다이렉션 상태 코드

- 클라이언트가 관심있어 하는 리소스에 대해 다른 위치를 사용하라고 말해주거나 그 리소스의 내용 대신 다른 대안 응답을 제공.
- 만약 리소스가 옮겨졌다면, 클라이언트에게 리소스가 옮겨졌으며 어디서 찾을 수 있는지 알려주기 위해 리다이렉션 상태 코드와 `Location` 헤더(선택)를 보낼 수 있음.
- 브라우저가 사용자를 귀찮게 하지 않고 알아서 새 위치로 이동할 수 있게 해줌.
- 몇몇 코드는 리소스에 대한 애플리케이션의 로컬 복사본이 원래 서버와 비교했을 때 유효한지 확인하기 위해 사용.
  - 그의 리소스에 대한 로컬 복사본이 여전히 최신인지 혹은 원래 서버에 있는 리소스가 수정되었는지 검사 가능.
- `HEAD`가 아닌 요청에 대해 리다이렉션 상태 코드를 포함한 응답을 할 때, 리다이렉트될 `URL`에 대한 링크와 설명을 포함시키는 것은 좋은 습관.

| 상태 코드 |     사유 구절      |                                                                                           의미                                                                                            |
| :-------: | :----------------: | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
|   `300`   |  Multiple Choices  |      클라이언트가 동시에 여러 리소스를 가리키는 `URL`을 요청한 경우, 그 리소스의 목록과 함께 반환. 어떤 서버가 하나의 `HTML` 문서를 영어와 프랑스어 모두로 제공하는 경우 등에 사용.       |
|   `301`   | Moved Permanently  |                                       요청한 `URL`이 옴ㄹ겨졌을 때 사용. 응답은 `Location` 헤더에 현재 리소스가 존재하고 있는 `URL`을 포함해야 함.                                        |
|   `302`   |       Found        |                         `301` 상태 코드와 같지만 `Location` 헤더로 주어진 `URL`을 리소스를 임시로 가리키기 위한 목적으로 사용. 이후의 요청에서는 원래 `URL` 사용.                         |
|   `303`   |     See Other      |             클라이언트에게 리소스를 다른 `URL`에서 가져와야한다고 말해주고자 할 때 쓰임. 새 `URL`은 응답 메세지의 `Location` 헤더에 들어있음. `POST` 요청에 대한 응답이 목적.             |
|   `304`   |    Not Modified    |              `GET`과 같은 조건부 요청을 보냈고 그 요청한 리소스가 최근에 수정된 일이 없다면, 이 코드는 리소스가 수정되지 않았음을 의미. 응답에 엔터티 본문을 포함해선 안됨.               |
|   `305`   |     Use Proxy      | 리소스가 반드시 프록시를 통해서 접근되어야 함을 나타내기 위해 사용. 프록시의 위치는 `Location` 헤더를 통해 주어짐. 클라이언트는 모든 요청에 대해 이 프록시를 통해야 한다고 상정하지 않음. |
|   `306`   |         X          |                                                                                             X                                                                                             |
|   `307`   | Temporary Redirect |                                    `301` 상태 코드와 비슷하지만 `Location` 헤더로 주어진 `URL`을 리소스를 임시로 가리키기 위한 목적으로 사용되어야 함.                                    |

- 상태 코드 사이에 중복되는 부분이 있는데, 이는 `HTTP/1.0`과 `HTTP/1.1` 애플리케이션이 이 상태 코드를 다루는 방식의 차이점에 기인.

> 결국 서버는 리다이렉트 응답에 들어갈 가장 적절한 리다이렉트 상태 코드를 선택하기 위해 클라이언트의 `HTTP` 버전을 검사할 필요가 있음.

### `400`-`499`: 클라이언트 에러 상태 코드

- 잘못 구성된 요청 메세지 등 클라이언트에서 잘못된 요청을 보낼 경우에 사용하는 코드.
- 많은 클라이언트 에러가 브라우저에 의해 처리됨.

| 상태 코드 |            사유 구절            | 의미 |
| :-------: | :-----------------------------: | :--: |
|   `400`   |           Bad Request           |      |
|   `401`   |          Unauthorized           |      |
|   `402`   |        Payment Required         |      |
|   `403`   |            Forbidden            |      |
|   `404`   |            Not Found            |      |
|   `405`   |       Method Not Allowed        |      |
|   `406`   |         Not Acceptable          |      |
|   `407`   |      Proxy Authentication       |      |
|   `408`   |         Request Timeout         |      |
|   `409`   |            Conflict             |      |
|   `410`   |              Gone               |      |
|   `411`   |         Length Required         |      |
|   `412`   |       Precondition Failed       |      |
|   `413`   |    Request Entity Too Large     |      |
|   `414`   |      Request URI Too Long       |      |
|   `415`   |     Unsupported Media Type      |      |
|   `416`   | Requested Range Not Satisfiable |      |
|   `417`   |       Expectation Failed        |      |

### `500`-`599`: 서버 에러 상태 코드

- 클라이언트는 올바른 요청을 보냈으나, 서버 자체에서 에러가 발생하는 경우에 사용하는 코드.

| 상태 코드 |         사유 구절          | 의미 |
| :-------: | :------------------------: | :--: |
|   `500`   |   Internal Server Error    |      |
|   `501`   |      Not Implemented       |      |
|   `502`   |        Bad Gateway         |      |
|   `503`   |    Service Unavailable     |      |
|   `504`   |      Gateway Timeout       |      |
|   `505`   | HTTP Version Not Supported |      |

---

## 헤더

### 일반 헤더

#### 일반 캐시 헤더

### 요청 헤더

#### `Accept` 관련 헤더

#### 조건부 요청 헤더

#### 요청 보안 헤더

#### 프록시 요청 헤더

### 응답 헤더

#### 협상 헤더

#### 응답 보안 헤더

### 엔터티 헤더

#### 콘텐츠 헤더

#### 엔터티 캐싱 헤더
