# 7장 캐시

웹 캐시는 자주 사용되는 문서의 사본을 자동으로 보관하는 HTTP 장치다.

<br>

## 7.1 불필요한 데이터 전송

- 캐시는 불필요한 데이터 전송을 줄여서, 네트워크 요금으로 인한 비용을 줄여준다.
- 캐시를 이용하면 첫 번째 서버 응답이 캐시에 보관되고, 캐시된 사본이 뒤이은 요청들의 응답으로 사용될 수 있다.
- 이를 통해 불필요한 데이터 전송을 방지해 트래픽 낭비를 줄일 수 있다.
- 불필요한 데이터 전송은 값비싼 네트워크 대역폭을 잡아먹고 전송을 느리게 만들며, 웹 서버에 부하를 준다.

<br>

## 7.2 대역폭 병목

- 캐시는 네트워크 병목을 줄여준다. 대역폭을 늘리지 않고도 페이지를 빨리 불러올 수 있게 된다.
- 대부분의 네트워크는 원격보다 로컬의 네트워크 클라이언트에 더 넓은 대역폭을 제공한다.
- 클라이언트들이 서버에 접근할 때 속도는 그 경로의 가장 느린 네트워크의 속도와 같다.
- 만약 클라이언트가 빠른 LAN에 있는 캐시로부터 사본을 가져오면, 특히 큰 문서에 대해 캐싱은 성능을 대폭 개선할 수 있을 것이다.
- 대역폭은 큰 문서에 현저한 지연을 일으키며 속도는 네트워크 종류의 차이에 따라 극적으로 달라진다.

<br>

## 7.3 갑작스런 요청 쇄도(Flash Crowds)

- 캐시는 원 서버에 대한 요청을 줄여준다.
- 갑작스런 요청 쇄도는 웹 서버에 과부하를 준다. 따라서 캐싱은 이를 대처하기 위해 특히 중요하다.

<br>

## 7.4 거리로 인한 지연

- 페이지를 먼 곳에서 불러올수록 시간이 많이 걸리는데, 캐시는 거리로 인한 지연을 줄여준다.
- 대역폭뿐만 아니라 거리가 지연에 원인이 될 수 있다. 모든 네트워크 라우터는 제각각 인터넷 트래픽을 지연시킨다.
- 기계실 근처에 캐시를 설치해 문서가 전송되는 거리를 수천 킬로미터에서 수십 미터로 줄일 수 있다.

<br>

## 7.5 적중과 부적중

- 캐시 적중이란 요청이 도착했을 때, 그에 대응하는 사본이 있다면 그를 이용해 요청이 처리하는 것이다.
- 캐시 부적중이란 대응하는 사본이 없어 원 서버로 전달되도록 처리하는 것이다.

### 7.5.1 재검사(Revalidation)

- 원 서버 콘텐츠는 변경될 수 있기 때문에, 캐시는 갖고 있는 사본이 여전히 최신인지 서버를 통해 때떄로 점검해야 한다.(HTTP 재검사)
- 캐시는 스스로 원할 때 언제든지 사본을 재검사할 수 있지만 대부분은 사본이 충분히 오래된 경우에만 재검사를 한다.

#### 재검사 적중(느린 적중)

- 재검사가 필요할 때 캐시는 원 서버에 작은 재검사 요청을 보내고, 콘텐츠가 변경되지 않았다면 서버는 아주 작은 `304 Not modified` 응답을 보낸다.
- 서버 응답을 통해 사본의 유효함을 알게 된 캐시는 즉각 사본이 신선함을 임시로 다시 표시한 뒤 사본을 클라이언트에게 제공한다.
- 캐시 적중보다 느리고, 캐시 부적중보다 빠르다.

#### `If-Modified-Since` 헤더

- HTTP는 캐시된 객체를 재확인하기 위해 몇 가지 도구 중 가장 많이 사용되는 헤더다.
- 서버에 보내는 GET 요청에 이 헤더를 추가하면 캐시된 시간 이후 변경된 경우에만 사본을 보내달라는 의미이다.
- `GET If-Modified-Since` 요청이 서버에 도착하면 다음과 같은 상황이 발생할 수 있다.
  - 재검사 적중: 서버 객체가 변경되지 않았다면, 서버는 클라이언트에게 작은 `304 Not modified` 응답을 보낸다.
  - 재검사 부적중: 서버 객체가 캐시된 사본과 다르다면, 서버는 콘텐츠 전체와 함께 평범한 `HTTP 200 OK` 응답을 클라이언트에게 보낸다.
  - 객체 삭제: 서버 객체가 삭제되었다면, 서버는 `4040 Not Found` 응답을 돌려보내며, 캐시는 사본을 삭제한다.

### 7.5.2 적중률

- 캐시가 요청을 처리하는 비율을 캐시 적중률(캐시 적중비), 혹은 문서 적중률(문서 적중비)라고 부르기도 한다.
  - 0%: 모든 요청이 캐시 부적중 즉, 네트워크 너머로 문서를 가져온 경우다.
- 캐시 적중률은 다음과 같은 부분에 영향을 받는다. 40% 정도의 캐시 적중률이면 괜찮은 편으로 평가할 수 있다.
  - 캐시가 얼마나 큰지
  - 캐시 사용자들의 관심사가 얼마나 비슷한지
  - 캐시된 데이터가 얼마나 자주 변경되거나 개인화되는지
  - 캐시가 어떻게 설정되어 있는지
- 보통 크기의 캐시라도 충분히 자주 쓰이는 문서를 보관해 트래픽을 상당량 줄이고 성능을 개선할 수 있다.

### 7.5.3 바이트 적중률

- 바이트 단위 적중률은 캐시를 통해 제공된 모든 바이트의 비율을 표현한다.
  - 100%: 모든 바이트가 캐시에서 왔으며 어떤 트래픽도 인터넷으로 나가지 않았음을 의미한다.
- 문서 적중률, 바이트 단위 적중률 둘 다 캐시 성능에 대한 유용한 지표다.
  - 문서 적중률을 개선하면 전체 대기시간(지연)이 줄어든다.
  - 바이트 단위 적중률을 개선은 대역폭 절약을 최적화한다.

### 7.5.4 적중과 부적중의 구별

- HTTP는 클라이언트에게 응답이 캐시 적중이었는지, 원 서버 접근인지 말해줄 수 있는 방법을 제공하지 않는다.
- Via, Date, Age 헤더를 통해 부가적인 정보를 알 수 있다.
  - Via: 몇몇 상용 프락시 캐시는 캐시에 무슨 일이 있어났는지 설명하기 위해 Via 헤더에 추가 정보를 붙인다.
  - Date: 응답의 Date 헤더 값을 현재 시각과 비교하여 응답의 생성일이 더 오래되었다면 클라이언트는 응답이 캐시된 것임을 알아낼 수 있다.
  - Age: 클라이언트가 캐시된 응답을 감지하는 또 다른 방법은 응답이 얼마나 오래되었는지 말해주는 Age 헤더를 이용하는 것이다.

<br>

## 7.6 캐시 토폴로지

- 캐시는 한 명의 사용자에게만 할당되거나 또는 수천 명의 사용자들 간에 공유될 수도 있다.
- 개인 전용 캐시(private cache)는 개인만을 위한 것으로, 한 명의 사용자가 자주 찾는 페이지를 담는다.
- 공용 캐시(public cache)는 공유된 캐시이며 사용자 집단에게 자주 쓰이는 페이지를 담는다.

### 7.6.1 개인 전용 캐시

- 많은 에너지나 저장 공간이 필요하지 않아 작고 저렴할 수 있다.
- 개인 전용 캐시의 예로, 대부분의 브라우저는 자주 쓰이는 문서를 개인용 컴퓨터의 디스크와 메모리에 캐시하고, 사용자가 캐시 사이즈와 설정을 수정할 수 있게 한다.
- 캐시에 어떤 것이 있는지 조회할 수도 있다.
  - IE는 캐시된 문서를 '임시 파일'이라고 하며 연관된 URL 및 문서 만료 시각과 함께 파일 목록에 나열한다.
  - 크롬은 특별한 URL인 `about:cache`를 통해 연결되는 페이지에서 캐시 콘텐츠의 목록을 제공한다.
    - 버전 66 이전에는 이와 비슷한 "chrome://view-http-cache/" URL로 캐시 콘텐츠를 확인했는데 버전 66 이후 영구히 삭제되었다.([출처](https://smallbusiness.chron.com/access-google-chrome-cache-windows-30349.html))
    - 개발자 도구를 통해 캐시 콘텐츠를 확인할 수 있다. ([참고](https://developer.chrome.com/docs/devtools/storage/cache/))

### 7.6.2 공용 프락시 캐시

- 공용 캐시는 흔히 프락시 캐시라고 불리는 특별한 종류의 공유된 프락시 서버다.
- 프락시 캐시는 로컬 캐시에서 문서를 제공하거나, 사용자 입장에서 서버에 접근한다.
- 공용 캐시에서 캐시는 자주 찾는 객체를 단 한 번만 가져와 모든 요청에 대해 공유된 사본을 제공함으로써 네트워크 트래픽을 줄인다.
- 수동 프락시를 지정하거나 프락시 자동설정 파일을 설정함으로써 브라우저가 프락시 캐시를 사용하게 설정할 수 있다.
- 인터셉트 프락시를 사용하여 브라우저의 설정 없이 HTTP 요청이 캐시를 통하도록 강제할 수 있다.

### 7.6.3 프락시 캐시 계층들(p. 196)

- 작은 캐시에서 캐시 부적중이 발생했을 때, 부모 캐시가 그 남겨진 트래픽을 처리하도록 하는 계층을 만드는 경우가 많다.
- 클라이언트는 주위에 작고 저렴한 캐시를 사용하고 계층 상단에는 많은 사용자들에 의해 공유되는 문서를 유지하기 위해 더 크고 강력한 캐시를 사용자하는 것이다.
- 계츠잉 깊어져 프락시 연쇄가 길어질수록 각 중간 프락시는 현저한 성능 저하가 발생한다.

### 7.6.4 캐시망, 콘텐츠 라우팅, 피어링

- 몇몇 네트워크 아키텍처는 단순한 캐시 계층 대신 복잡한 캐시망을 만든다.
- 캐시망의 프락시 캐시는 복잡한 방법으로 서로 대화하여 요청 처리에 대한 결정을 동적으로 내린다.
- 캐시망 안에서 콘텐츠 라우팅을 위해 설계된 캐시들은 다음과 같은 동작을 한다.
  - URL에 근거해 부모 캐시와 원 서버중 하나를 동적으로 선택하고, 특정 부모 캐시를 동적으로 선택한다.
  - 부모 캐시에 가기 전에 캐시된 사본을 로컬에서 찾아본다.
  - 다른 캐시들이 그들의 캐시된 콘텐츠에 부분 접근할 수 있도록 허용하되, 캐시를 통해 트래픽이 다른 네트워크로 건너가는 것(인터넷 트랜짓)은 허용하지 않는다.
- 이러한 복잡한 캐시 사이의 관계는 서로 다른 조직들이 상호 이득을 위해 그들의 캐시를 연결하여 서로 찾아볼 수 있게 해준다.
- 선택적인 연결을 지원하는 캐시는 형제 캐시라고 하며 HTTP는 이를 지원하지 않기 때문에 인터넷 캐시 프로토콜(ICP)나 하이퍼텍스트 캐시 프로토콜(HTCP) 같은 프로토콜을 이용해 HTTP를 확장했다.

<br>

## 7.7 캐시 처리 단계(p. 201 플로 차트)

1. 요청 받기: 캐시는 네트워크로부터 도착한 요청 메시지를 읽는다.
   - 네트워크 커넥션에서의 활동을 감지하고 들어오는 데이터를 읽어들인다.
2. 파싱: 캐시는 메시지를 파싱하여 URL과 헤더들을 추출한다.
   - 캐시는 요청 메시지를 여러 부분으로 파싱하여 헤더 부분을 조작하기 쉬운 자료구조에 담는다
3. 검색: 캐시는 로컬 복사본이 있는지 검사하고, 사본이 없었다면 사본을 받아온다.(그리고 로컬에 저장한다)
   - 캐시는 URL을 알아내고 그에 해당하는 로컬 사본이 있는지 검사한다.
   - 로컬에서 문서를 가져올 수 없다면, 캐시는 상황이나 설정에 따라 원 서버나 부모 프락시에서 가져오거나 혹은 실패를 반환한다.
   - 캐시된 객체는 객체가 얼마나 오래 캐시에 머무르고 있었는지 알려주는 기록이나 얼마나 자주 사용되었는지 등 몇몇 메타 데이터를 포함한다.
4. 신선도 검사: 캐시는 캐시된 사본이 충분히 신선한지 검사하고, 신선하지 않다면 변경사항이 있는지 서버에 물어본다.
   - 캐시된 사본을 신선도 한계를 넘을 정도로 오래 갖고 있었다면 그 객체는 '신선하지 않은'것으로 간주되며, 캐시는 그것을 제공하기 전에 문서에 어떤 변경이 있었는지 검사하기 위해 서버와 재검사를 해야한다.
5. 응답 생성: 캐시는 새로운 헤더와 캐시된 본문으로 응답 메시지를 만든다.
   - 캐시된 응답을 원 서버에서 온 것처럼 보이게 하려고 캐시는 캐시된 서버 응답헤더를 토대로 응답 헤더를 생성한다. 이 기저 헤더들은 캐시에 의해 수정되고 늘어난다.
6. 발송: 캐시는 네트워크를 통해 응답을 클라이언트에게 돌려준다.
7. 로깅: 선택적으로, 캐시는 로그파일에 트랜잭션에 대해 서술한 로그 하나를 남긴다.
   - 각 캐시 트랜잭션 완료 후, 캐시는 통계 캐시 적중과 부적중 횟수(그리고 다른 관련 지표들)에 대한 통계를 갱신하고 로그 파일에 요청 종류, URL, 무엇이 일어났는지 알려주는 항목을 추가한다.

<br>

## 7.8 사본을 신선하게 유지하기

- 캐시된 사본 모두 서버 문서와 항상 일치하는 것은 아니며 문서는 시간에 따라 변경된다.
- HTTP는 어떤 캐시가 사본을 갖고 있는지 서버가 기억하지 않더라도, 캐시된 사본이 서버와 충분히 일치하도록 유지할 수 있게 해주는 단순한 메커니즘(문서 만료, 서버 재검사)을 갖고 있다.

### 7.8.1 문서 만료

- 클라이언트는 Cache-Control과 Expires라는 특별한 헤더들을 이용해 원 서버가 각 문서에 유효기간을 붙일 수 있게 해준다.
- 이 헤더들은 콘텐츠가 얼마나 오래 신선한 상태로 보일 수 있는지 좌우한다.
- 캐시 문서 만료 전, 캐시는 필요하면 서버와의 접촉 없이 사본을 제공할 수 있다.
- 캐시된 문서가 만료되면, 캐시는 반드시 서버와 문서에 변경된 것이 있는지 검사해 새 유효기간과 함께 신선한 사본을 함께 얻어와야 한다.

### 7.8.2 유효기간과 나이

- 서버는 응답 본문과 함께하는 HTTP/1.0+ Expires나 HTTP/1.1 Cache-Control:max-age 응답 헤더를 이용해 유효기간을 명시한다.
  - Cache-Control:max-age: 문서의 최대 나이 정의, 초 단위
  - Expires: 절대 유효기간 명시

### 7.8.3 서버 재검사

- 캐시된 문서가 만료되었다는 것은 문서가 원 서버에 존재하는 것과 같은지 검사할 시간이 되었음을 뜻한다.
  - 재검사 결과 콘텐츠가 변경되었다면, 캐시는 그 새로운 사본을 가져와 오래된 데이터 대신 저장한 뒤 클라이언트에게도 보내준다.
  - 그렇지 않다면, 캐시는 새 만료일을 포함한 새 헤더들만 가져와서 캐시 안의 헤더들을 갱신한다.
- 문서 만료시 한 번만 서버와 재검사하면 된다.
- 이는 신선하지 않은 콘텐츠는 제공하지 않으면서도, 서버 트래픽을 절약하고 사용자 응답 시간을 개선한다.

### 7.8.4 조건부 메서드와의 재검사

- HTTP 조건부 메서드는 재검사를 효율적으로 만들어준다.
  - HTTP는 캐시가 서버에게 '조건부 GET'이라는 요청을 보낼 수 있게 한다.
  - 서버가 갖고 있는 문서가 캐시가 갖고 있는 것과 다른 경우에만 객체 본문을 보내달라고 하는 것이다.
  - 이렇게 신선도 검사와 객체를 받아오는 것은 하나의 조건부 GET으로 결합된다. 조건부 GET은 GET 요청 메시지에 특별한 조건부 헤더를 추가함으로써 시작된다.
  - 웹 서버는 조건이 참인 경우에만 객체를 반환한다.
- 조건부 요청 헤더의 종류인 If-Modified-Since와 If-None-Match는 캐시 재검사를 할 때 유용하다.
  - `If-Modified-Since: <date>`: 문서가 주어진 날짜 이후로 수정되었다면 요청 메서드를 처리한다.
  - `If-None-Match: <tags>`: 마지막 변경된 날짜를 맞춰보는 대신, 서버는 문서에 대한 일련번호와 같이 동작하는 특별한 태그를 제공할 수 있다.

### 7.8.5 If-Modified-Since: 날짜 재검사

- If-Modified-Since 재검사 요청은 'IMS' 요청으로 불리며 가장 흔히 쓰인다.
- IMS 요청은 서버에게 리소스가 특정 날짜 이후로 변경된 경우에만 요청한 본문을 보내달라고 한다.
- 문서가 주어진 날짜 이후에 변경되었다면 If-Modified-Since 조건은 참이 되고, GET 요청은 성공한다.
- 문서가 주어진 날짜 이후에 변경되지 않았다면 조건은 거짓이고, 서버는 작은 304 Not Modified 응답 메시지를 클라이언트에게 돌려준다. 본문은 보내지 않는다.
- 서버 응답 헤더의 Last-Modified 헤더와 함께 동작한다.
  - 원 서버는 제공하는 문서에 최근 변경 일시를 붙인다.
  - 캐시가 캐시된 문서를 재검사 하려고 할 때 캐시된 사본이 마지막으로 수정된 날짜가 담긴 If-Modified-Since 헤더를 포함한다. `If-Modified-Since: <캐시된 마지막 수정일>`
- 몇 웹 서버는 If-Modified-Since를 실제 날짜 비교로 구현하지 않는다.
  - IMS 날짜와 최근 변경일 간의 문자열 비교를 수행한다.

### 7.8.6 If-None-Match: 엔터티 태그 재검사

- 엔터티 태그가 변경되었다면 캐시는 새 문서의 사본을 얻기(GET)위해 If-None-Match 조건부 헤더를 사용할 수 있다.
  - 요청(캐시가 원 서버에게 태그가 v2.6이 아닌 경우에만 새 객체를 달라고 요청)
  ```
  GET /...html HTTP/1.0
  If-None-Match: "v2.6"
  ```
  - 응답(v2.6 태그가 여전히 변경되지 않았음)
  ```
  HTTP/1.0 304 Not Modified
  Dat: ...
  Etag: "v2.6"
  Expires: ...
  ``
  ```
- 캐시가 객체에 대한 여러 개 사본을 갖고 있는 경우, 그것을 서버에 알리기 위해 하나의 If-None-Match 헤더에 여러 개의 엔터티 태그를 포함시킬 수 있다.

```
If-None-Match: "v2.6"
If-None-Match: "v2.4", "v2.5", "v2.6"
If-None-Match: "foobar", "A34FAC0095", "Profiles in Courage"
```

### 7.8.7 약한 검사기와 강한 검사기

- 약한 검사기는 콘텐츠가 조금 변경되었더라도 서버가 "그 정도면 같은 것이다"고 주장할 수 있게 해준다.(HTTP 1.1)
  - `W/`접두사로 약한 검사기를 구분한다.
    ```
    ETag: W/"v2.6"
    If-None-Match: W/"v2.6"
    ```
- 강한 검사기는 콘텐츠가 바뀔 때마다 바뀐다. 약한 검사기는 어느 정도 콘텐츠 변경을 허용하지만, 콘텐츠의 중요한 의미가 변경되면 함께 변경된다.

### 7.8.8 언제 엔터티 태그를 사용하고 언제 Last-Modified 일시를 사용하는가

- HTTP/1.1 클라이언트는 서버가 엔터티 태그를 반환했다면, 반드시 엔터티 태그 검사를 해야 한다.
- 서버가 Last-Modified 값만을 반환했다면, 클라이언트는 If-Modified-Since 검사를 사용할 수 있다.

<br>

## 7.9 캐시 제어

- HTTP는 문서가 만료되기 전까지 얼마나 오래 캐시될 수 있게 할 것인지 서버가 설정할 수 있는 여러 방법을 정의한다.
- 다음과 같은 우선 순위를 갖는다.
  - Cache-Control: no-store 헤더
  - Cache-Control: no-cache 헤더
  - Cache-Control: must-revalidate 헤더
  - 클라이언트는 Cache-Control: max-age 헤더
  - Expires 날짜 헤더.
  - 아무 만료 정보도 주지 않고 캐시가 스스로 체험적인(휴리스틱) 방법으로 결정하게 할 수 있다.

### 7.9.1 no-cache와 no-store 응답 헤더

- no-store와 no-cache 헤더는 캐시가 검증되지 않은 캐시된 객체로 응답하는 것을 막는다.
  - no-store: 캐시가 그 응답의 사본을 만드는 것을 금지한다. 캐시는 보통 캐시가 아닌 프락시 서버가 그러듯 클라이언트에게 no-store 응답을 전달하고 나면 객체를 삭제할 것이다.
  - no-cache: 이 응답은 로컬 캐시 저장소에 저장될 수 있다. 다만 먼저 서버와 재검사를 하지 않고서는 캐시에서 클라이언트로 제공될 수 없다.
- Pragma: no-cache 헤더는 HTTP/1.0+와의 하위호환성을 위해 HTTP/1.1에 포함되어 있다.
- HTTP/1.0 애플리케이션에 대응해야 하는 경우가 Cache-Control: no-cache를 사용해야 한다.

### 7.9.2 Max-Age 응답 헤더

- max-age 헤더는 신선하다고 간주되었던 문서가 서버로부터 온 후 흐른 시간이고, 초로 나타낸다.
- s-maxage 헤더는 공유된 공용 캐시에만 적용된다.
- 서버는 최대 나이먹음(maximum aging)을 0으로 설정함으로써 캐시가 매 접근마다 문서를 캐시하거나 리프레시하지 않도록 요청할 수 있다.

### 7.9.3 Expires 응답 헤더

- 더 이상 사용하지 않기를 권하는 헤더이며 초 단위의 시간 대신 실제 만료 날짜를 명시한다.
- 몇 서버는 문서를 항상 만료되도록 하기 위해 Expires: 0 응답 헤더를 만드는 건 문제를 일으킬 수 있다.

### 7.9.4 Must-Revalidate 응답 헤더

- 캐시가 만료 정보를 엄격하게 따르길 원한다면 원 서버는 Cache-Control: must-revalidate를 붙일 수 있다.

### 7.9.5 휴리스틱 만료

- 클라이언트는 Cache-Control: max-age 헤더나 Expires 헤더 중 어느 것도 포함하지 않으면, 캐시는 경험적인 방법(휴리스틱)으로 최대 나이를 계산한다.
- 휴리스틱 신선도 계산은 생각보다 흔히 하게 된다. 많은 원 서버가 아직도 Expires와 max-age 헤더를 생성하지 못하므로 캐시의 만료 기본값을 신중하게 선택해야 한다.

### 7.9.6 클라이언트 신선도 제약

- 웹 브라우저에는 브라우저나 프락시 캐시의 신선하지 않은 콘텐츠를 강제로 갱신시켜주는 리프레시나 리로드 버튼이 있다.
- 이 버튼은 Cache-Control 요청 헤더가 추가된 GET 요청을 발생시켜 강제로 재검사하거나 서버로부터 콘텐츠를 무조건 가져온다.
- 클라이언트는 Cache-Control 요청 헤더를 사용해 만료 제약을 엄격하거나 느슨하게 할 수 있다.
  - `Cache-Control: max-stale / Cache-Control: max-stale = <s>` : `<s>` 값 만큼 지난 문서도 받아들인다.
  - `Cache-Control: min-fresh = <s>`: `<s>`초 후까지 신선한 문서만을 받아들인다.
  - `Cache-Control: max-age = <s>`: 캐시는 `<s>`초보다 오래 캐시된 문서를 반환할 수 없다.
  - `Cache-Control: no-cache / Pragma: no-cache` : 캐시된 리소스를 재검사하기 전에는 받아들이지 않는다.
  - `Cache-Control: no-store` : 캐시는 저장소에서 문서의 흔적을 최대한 빨리 삭제해야 한다.
  - `Cache-Control: only-if-cached`: 클라이언트는 캐시에 들어있는 사본만을 원한다.

### 7.9.7 주의할 점

- 문서 만료는 완벽한 시스템이 아니므로 유효기간을 길게 잡지 않는다.

<br>

## 7.10 캐시 제어 설정

- 웹 서버는 캐시 제어와 만료 HTTP 헤더들을 설정하는 서로 다른 매커니즘을 제공한다.

### 7.10.1 아파치로 HTTP 헤더 제어하기

- 아파치 웹 서버는 HTTP 캐시 제어 헤더를 설정하는 여러 매커니즘을 제공하는데, 사용하려면 일단 활성화시켜야 한다.

##### mod_headers

```
<Files *.html>
  Header set Cache-Control no-cache
</Files>
```

- 개별 헤더들을 설정할 수 있게 한다.

##### mod_expires

```
ExpiresDefault A3600
ExpiresDefault M86400
ExpiresDefault "access plus 1 week"
ExpiresDefault text/html "modification plus 2 days 6 hours 12 minutes"
```

- 적절한 만료 날짜가 담긴 Expires 헤더를 자동으로 생성하는 프로그램 로직을 제공한다.

##### mod_cem_meta

- HTTP 헤더들의 파일을 특정 객체와 연결시켜준다.

### 7.10.2 HTTP-EQUIV를 통한 HTML 캐시 제어

```html
<html>
  <head>
    <title>Document</title>
    <meta http-equiv="Cache-control" content="no-cache" />
  </head>
</html>
```

- HTML 2.0은 `<META HTTP-EQUIV>` 태그를 정의했다. 이것은 문서 최상단에 위치하여 문서와 연동되어야 하는 HTTP 헤더들을 정의한다.
- `<META HTTP-EQUIV>` 태그는 문서의 캐시 동작을 제어하는 서투른 방법이다. 문서의 캐시 제어 요청과 커뮤니케이션하는 유일하게 확실한 방법은 올바르게 설정된 서버가 보내온 HTTP 헤더를 이용하는 것이다.

<br>

## 7.11 자세한 알고리즘(p. 216)

> 캐시 내부에 대한 세부적인 내용이므로 생략

- HTTP 명세는 문서의 나이와 캐시 신선도를 계산하는 복잡한 알고리즘을 제공한다.

<br>

## 7.12 캐시와 광고

- 캐시는 사용자들에게 좋은 경험을 제공하고 네트워크 사업자들이 트래픽을 줄일 수 있게 한다.

### 7.12.1 광고 회사의 딜레마

- 캐시는 광고나 기사를 빠르게 잘 보여주며 콘텐츠를 더 많이 소비하게 한다.
- 그러나 캐시가 완벽하게 동작해 원 서버가 HTTP 접근을 전혀 수신하지 않게 되면 접근 횟수에 따라 수익을 창출하는 사업자는 큰 이득을 볼 수 없다.

### 7.12.2 퍼블리셔의 응답

- 캐시가 광고 시청 수를 가로채지 못하게 모든 종류의 캐시 무력화 기법을 사용한다.
- 광고를 CGI 게이트웨이를 통해 제공해 매 접근마다 광고 URL을 고쳐 쓴다.
- 이 기법은 단지 프락시 캐시만에 대한 것이 아니며 오늘날 주로 모든 웹 브라우저에서 켜져 있는 캐시를 주요 대상으로 한다.
- 이상적으로는 캐시가 트래픽을 흡수하도록 내버려 두어야 하며 캐시는 그들에게 적중이 얼마나 많이 일어났는지 알려주어야 한다.

### 7.12.3 로그 마이그레이션

- 캐시는 모든 적중 로그를 유지할 수 있다. 이 로그를 서버에게 나누어 줌으로써 콘텐츠 제공자들에게 이익을 줄 수 있다.
- 그러나 적중 로그는 크기 때문에 옮기기 어렵고 표준화 및 프라이버스 이슈가 있다.

### 7.12.4 적중 측정과 사용량 제한

- RFC 2227 프로토콜은 HTTP에 때때로 특정 URL에 대한 캐시 적중 횟수를 정기적으로 서버에게 돌려주는 Meter라는 새 헤더를 하나 추가한다.
- 서버는 캐시된 문서가 적중한 횟수를 캐시로부터 정기적으로 전달 받는다.
