# 6장 프락시

## 6.1 웹 중개자

- 웹 프락시 서버는 클라이언트 입장에서 트랜잭션을 수행하는 중개인이다.
- 프락시는 서버이면서 동시에 클라이언트다.
  - 프락시는 클라이언트의 요청을 받게 되므로, 웹 서버처럼 요청과 커넥션을 적절히 다루고 응답을 돌려줘야 한다.
  - 프락시는 요청을 서버로 보내기도 하므로, 요청을 보내고 응답을 받는 HTTP 클라이언트처럼 동작해야 한다.

### 6.1.1 개인프락시와 공유 프락시

#### 공용 프락시

- 대부분의 프락시는 공용이며 공유된 프락시다.
- 중앙 집중형 프락시를 관리하는 게 비용효율이 높고 쉽다.
- 여러 사용자들에게 공통된 요청에서 이득을 취하기 쉬우므로 캐시 프락시 서버와 같은 프락시 서버는 사용자가 많을수록 효율이 좋다.

#### 개인 프락시

- 흔하지 않지만 클라이언트 컴퓨터에서 직접 실행되는 형태로 꾸준히 사용된다.

### 6.1.2 프락시 대 게이트웨이

- 프락시는 같은 프로토콜을 사용하는 둘 이상의 애플리케이션을 연결하며 클라이언트와 서버 양쪽 모두에게 HTTP로 통신한다.
- 게이트웨이는 서로 다른 프로토콜을 사용한는 둘 이상의 애플리케이션을 연결한다.
- 클라이언트와는 HTTP로 서버와는 POP으로 서로 다른 프로토콜로 말하더라도 서로 간의 트랜잭션을 완료하도록 한다.

<br>

## 6.2 왜 프락시를 사용하는가?

- 프락시 서버는 보안을 개선하고 성능을 높여주며 비용을 절약한다.
- 모든 프락시 서버는 HTTP 트래픽을 보고 건드릴 수 있기 때문에, 유용한 웹 서비스를 구현하기 위해 트래픽을 감시하고 수정한다.

다음은 프락시를 사용하는 예시다.

- 어린이 필터
  - 교육 콘텐츠에는 제한 없는 접근을 허용하면서 어린이에게 부적절한 사이트의 접근을 강제로 거부할 수 있다.
- 문서 접근 제어자
  - 중앙 프락시 서버에서 각기 다른 조직에서 관리되는 다양한 종류의 수많은 웹 서버들에 대한 접근 제어가 가능하다.
- 보안 방화벽
  - 바이러스를 제거하는 웹이나 이메일 프락시가 사용할 수 있는 트래픽을 세심하게 살펴볼 수 있는 훅을 제공한다.
- 웹 캐시
  - 인터넷 트래픽 조건과 콘텐츠의 종류에 따라 요청을 특정 웹 서버로 유도하는 콘텐츠 라우터로 동작할 수 있다.
- 대리 프락시(surrogate)
  - 웹 서버인 것처럼 위장한 대리 프락시를 통해 느린 웹 서버의 성능을 개선할 수 있다.
- 익명화 프락시(anonymizer)
  - HTTP 메세지에서 신원을 식별할 수 있는 특성들을 제거함으로써 개인 정보 보호와 익명성 보장에 기여한다. (IP주소, From 헤더, Referer 헤더, 쿠키, URI 세션 아이디 등)

<br>

## 6.3 프락시는 어디에 있는가?

프락시는 사용 목적에 따라 여러가지 방식으로 배치될 수 있다.

### 6.3.1 프락시 서버 배치(p.156)

#### 출구 프락시

- 로컬 네트워크와 더 큰 인터넷 사이를 오가는 트래픽을 제어하기 위해 프락시를 로컬 네트워크의 출구에 넣을 수 있다.
- 방화벽, 인터넷 요금 절약, 트랙픽 개선 등을 개선할 수 있다.

#### 접근(입구) 프락시

- 고객으로 부터의 모든 요청을 종합적으로 처리하기 위해 프락시는 ISP 접근 지점에 위치한다.
- 다운로드 속도 개선 및 인터넷 대역폭 비용을 줄일 수 있다.

#### 대리 프락시

- 네트워크의 가장 끝에 있는 웹 서버들의 바로 앞에 위치하여 웹 서버로 향하는 모든 요청을 처리하고 필요할 때만 웹 서버에게 자원을 요청할 수 있다.
- 빠른 웹 서버 캐시를 느린 웹 서버 앞에 놓음으로써 성능을 개선할 수 있다.

#### 네트워크 교환 프락시

- 캐시를 이용해 인터넷 교차로의 혼잡을 완화하고 트래픽 흐름을 감시한다.

### 6.3.2 프락시 계층

- 프락시는 계층으로 연쇄적 구성이 가능하다.
- 프락시 서버들은 부모와 자식의 관계를 갖는다.
- 자식들은 부모들의 작업량 수준, URL, 지역 등에 근거해 동적으로 부모 프락시를 선택할 수 있다.

### 6.3.3 어떻게 프락시가 트래픽을 처리하는가

클라이언트 트래픽이 프락시로 가도록 만드는 방법에는 4가지가 있다.

#### 클라이언트를 수정한다

- 많은 웹 브라우저들은 수동 또는 자동 프락시 설정을 지원한다.
- 클라이언트가 프락시를 사용하도록 설정되어 있다면 HTTP 요청을 바로 프락시로 보낸다.

#### 네트워크를 수정한다

- 클라이언트가 간섭할 수 없는 상태에서는 인터셉트 프락시 즉, HTTP 트래픽을 지켜보고 가로채 프락시로 보낸다.

#### DNS 이름공간을 수정한다

- 웹 서버 앞에 위치하는 대리 프락시 서버는 웹 서버의 이름과 IP주소를 자신이 직접 사용한다.

#### 웹 서버를 수정한다

- HTTP 리다이렉션 명령(305)을 클라이언트에게 돌려줌으로써 클라이언트의 요청을 프락시로 리다이렉트 하도록 설정할 수 있다.

<br>

## 6.4 클라이언트 프락시 설정

모던 브라우저들은 프락시를 설정할 수 있는 여러가지 방법을 제공한다.

### 6.4.1 클라이언트 프락시 설정: 수동

- 프락시의 호스트와 포트를 지정해 브라우저 설정에서 직접 설정한다.

### 6.4.2 클라이언트 프락시 파일: PAC 파일

- 프락시 자동 설정 파일(PAC) 즉, 동적으로 프락시 설정을 계산해주는 자바스크립트 프로그램을 통해 적절한 프락시 서버를 선택한다.

### 6.4.3 클라이언트 프락시 설정: WPAD

- 웹 프락시 자동발견 프로토콜(WPAD)는 브라우저에게 알맞는 PAC 파일을 자동으로 찾아주는 알고리즘이다.

> 관련된 자세한 내용은 20장에 있다.

<br>

## 6.5 프락시 요청의 미묘한 특징들

### 6.5.1 프락시 URI는 서버 URI와 다르다

- 클라이언트가 프락시 대신 서버로 요청을 보내면 URI가 달라진다.
- 요청줄에 스킴, 호스트, 포트번호가 존재하지 않아 프락시가 목적지 서버와 커넥션을 맺을 수 없는 문제가 발생했다.
- 클라이언트가 프락시를 사용하지 않도록 설정되어 있으면 부분 URI를, 그렇지 않다면 완전한 URI를 보낸다.

### 6.5.2 가상 호스팅에서 일어나는 같은 문제

- 스킴/호스트/포트번호 누락 문제는 가상으로 호스팅 되는 웹 서버의 문제와 같은 문제다.

### 6.5.3 인터셉트 프락시는 부분 URI를 받는다

- 인터셉트 프락시는 클라이언트에서 서버로 가는 트래픽을 가로채 캐시된 등답을 돌려주는 일을 한다.
- 따라서 웹 서버로 보내는 부분 URI를 얻게 될 것이다.

### 6.5.4 프락시는 프락시 요청과 서버 요청을 모두 다룰 수 있다

- 트래픽이 프락시 서버로 리다이렉트 될 수 잇는 여러가지 방법이 존재하기 때문에 다목적 프락시 서버는 요청 메시지의 와전한 URI와 부분 URI 모두 지원해야한다.
- 완전한 URI가 주어졌다면, 그것을 사용한다.
- 부분 URI 주어졌고 Host 헤더가 있다면, Host 헤더를 이용해 원 서버의 이름과 포트번호를 알아야한다.
- 부분 URI가 주어졌으나 Host 헤더가 없다면, 원 서버를 알아내야 한다.

### 6.5.5 전송 중 URI 변경

- 프락시 서버는 프로토콜을 엄격하게 준수도록 강제해선 안된다.

### 6.5.6 URI 클라이언트 자동확장과 호스트 명 분석

- 브라우저는 프락시의 존재 여부에 따라 요청 URI를 다르게 분석한다.
- 프락시가 없다면 타이핑된 URI를 가지고 대응되는 IP를 찾는다.
- 대응되는 IP가 없을 경우 브라우저는 서드파티 사이트, DNS등을 통해 자동화된 호스트 명의 확장을 제공한다.

### 6.5.7 프락시 없는 URI 분석

### 6.5.8 명시적인 프락시를 사용할 때의 URI 분석

- 명시적인 프락시 기술을 사용한다면 브라우저의 URI가 프락시를 그냥 지나쳐버리기 때문에 브라우저의 호스트명 확장을 사용할 수 없다.

### 6.5.9 인터셉트 프락시를 이용한 URI 분석

- 클라이언트 입장에서 인터셉터 프락시는 존재하지 않는 것이기 때문에 호스트 명 분석에 차이가 있다.(그림 6-18)

<br>

## 6.6 메시지 추적

- 웹 요청시에 클라이언트에 서버로 향하는 도중에 둘 이상의 프락시를 거치는 것은 흔해졌다.
- 프락시가 흔해지면서 서로 다른 스위치와 라우터를 넘나드는 IP 패킷의 흐름을 추적하는것 못지않게 프락시를 넘나드는 메시지의 흐름을 추적하고 문제점을 찾아내는 것이 중요하다.

### 6.6.1 Via 헤더

- Via 헤더 필드는 메시지가 지나는 각 중간 노드(프락시나 게이트웨이)의 정보를 나열한다.
- 메시지가 또 다른 노드를 지날 때마다, 중간 노드는 Via 목록의 끝에 반드시 추가되어야 한다.

#### Via 문법

- Via 헤더 필드는 쉼표로 구분된 경유지의 목록이다.
- 각 경유지는 개별 프락시 서버나 게이트웨이 홉을 나타내며 그들 중간 노드의 프로토콜과 주소에 대한 정보를 담고 있다.
- 프로토콜 이름 : HTTP, HTTPS, FTP 등
- 프로토콜 버전 : '1.0', '1.1' 등
- 노드 이름 : 호스트와 포트번호
- 노드 코멘트(선택)

#### Via가 개인정보 보호와 보안에 미치는 영향

- 프락시 서버가 네트워크 방화벽의 일부인 경우 프락시는 호스트이 이름과 포트 및 정보를 전달해서는 안된다.

### 6.6.2 TRACE 메서드

- HTTP/1.1 TRACE 메서드는 프락시의 연쇄를 따라가면서 어떤 프락시를 지나가고 요청 메시지를 수정하는 관찰/추적 할 수 있어 디버깅에 유용하다.

#### Max-Forwards

- TRACE 메시지는 프락시들이 몇 개나 있든 신경 쓰지 않고 목적지 서버로의 모든 경로를 여행한다.
- 프락시의 갯수를 제한하기 위해 Max-Forwards 헤더를 사용 할 수 있다.
- 테스트나, 무한루프 방지를 위해 사용된다.

<br>

## 6.7 프락시 인증

- 프락시는 접근 제어 장치로서 제공될 수 있다.
- HTTP는 사용자가 유효한 접근 권한 자격을 프락시에 제출하지 않는 한 콘텐츠에 대한 요청을 차단하는 프락시 인증을 제공한다.

<br>

## 6.8 프락시 상호운용성

- 클라이언트, 서버, 프락시는 여러 버전으로 여러 벤더 회사에 의해 만들어진다.
- 제각각의 버그들이 생기므로 프락시 서버는 클라이언트와 서버를 중개해야 한다.

### 6.8.1 지원하지 않는 헤더와 메서드 다루기

- 프락시 서버는 넘어오는 헤더 필드들을 모두 이해하지 못할 수 있다.
- 이해할 수 없는 헤더 필드는 반드시 그대로 전달해야 하며, 같은 이름의 헤더 필드가 여러개 있는 경우에는 그들의 상대적인 순서도 반드시 유지해야한다.

### 6.8.2 Options: 어떤 기능을 지원하는지 알아보기

- HTTP OPTIONS 메서드는 서버나 웹 서버의 특정 리소스가 어떤 기능을 지원하는지 알아볼 수 있게 해준다.
- 요청의 URI가 별표(`*`)라면, 요청은 서버 전체의 능력에 대해 묻는 것이 된다.
  - `OPTIONS * HTTP/1.1`
- URI가 실제 리소스라면, 특정 리소스에 대해 가능한 기능들을 묻는 것이다.

### 6.8.3 Allow 헤더

`Allow: GET, HEAD, PUT`

- 요청 URI에 의해 식별되는 자원에 대해 지원되는 메서드들이나 서버가 지원하는 모든 메서드를 열거한다.
- 클라이언트는 원 서버와 대화하는 다른 경로를 갖고 있을 수 있기 때문에, 프락시는 Allow 헤더 필드를 수정할 수 없다.
