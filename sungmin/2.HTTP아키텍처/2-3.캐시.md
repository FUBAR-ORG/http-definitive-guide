# 캐시

- 웹 캐시는 자주 쓰이는 문서의 사본을 자동으로 보관하는 HTTP 장치.
    - 웹 요청이 캐시에 도착했을 때, 캐시된 로컬 사본이 존재한다면, 그 문서는 원 서버가 아니라 그 캐시로부터 제공.
- 캐시의 이점
    1. 불필요한 데이터 전송을 줄여서, 네트워크 요금으로 인한 비용을 줄여줌.
    2. 네트워크 병목을 줄여줌. 대역폭을 늘리지 않고도 페이지를 빨리 불러올 수 있음.
    3. 원 서버에 대한 요청을 줄여줌. 서버는 부하를 줄일 수 있으며 더 빨리 응답할 수 있게 됨.
    4. 페이지를 먼 곳에서 불러올수록 시간이 많이 걸리는데, 캐시는 거리로 인한 지연을 줄여줌.

## 7.1 불필요한 데이터 전송

- 복수의 클라이언트가 자주 쓰이는 원 서버 페이지에 접근할 때, 서버는 같은 문서를 클라이언트들에게 각각 한 번씩 전송하게 됨.
- 똑같은 바이트들이 네트워크를 통해 계속 반복해서 이동하게 되는데, 이 불필요한 데이터 전송은 값비싼 네트워크 대역폭을 잡아먹고, 전송을 느리게 만들며, 웹 서버에 부하를 줌.
- 캐시를 이용하면, 첫 번째 서버 응답은 캐시에 보관, 캐시된 사본이 뒤이은 요청들에 대한 응답으로 사용될 수 있기 때문에, 원 서버가 중복해서 트래픽을 주고받는 낭비가 줄어듬.

## 7.2 대역폭 병목

- 캐시는 네트워크 병목을 줄여줌.
- 많은 네트워크가 원격 서버보다 로컬 네트워크 클라이언트에 더 넓은 대역폭을 제공.
- 클라이언트들이 서버에 접근할 때의 속도는, 그 경로에 있는 가장 느린 네트워크의 속도와 같음.

## 7.3 갑작스런 요청 쇄도(Flash Crowds)

- 캐싱은 갑작스런 요청 쇄도에 대처하기에 특히 중요
- 갑작스런 사건으로 인해 많은 사람이 거의 동시에 웹 문서에 접근할 때 발생하는 불필요한 트래픽 급증은 네트워크와 웹 서버의 심각한 장애를 야기.

## 7.4 거리로 인한 지연

- 모든 네트워크 라우터는 제각각 인터넷 트래픽을 지연시킴.
- 클라이언트와 서버 사이의 라우터가 그다지 많지 않더라도, 빛의 속도 그 자체가 유의미한 지연을 유발.
- 보통 수준으로 복잡한 웹 페이지들은 빛의 속도로 인한 지연이 수 초에 달할 수도 있음.

> 캐시를 설치해서 문서가 전송되는 거리를 수천 킬로미터에서 수십 미터로 줄일 수 있음.

## 7.5 적중과 부적중

- 캐시가 세상 모든 문서의 사본을 저장하지는 않음.
- 캐시 적중(cache hit): 캐시에 요청이 도착했을 때, 그에 대응하는 사본이 있다면 그를 이용해 요청이 처리되는 것.
- 캐시 부적중(cache miss): 대응하는 사본이 없어 원서버로 전달되는 것.

### 7.5.1 재검사(Revalidation)

- 원 서버 콘텐츠는 변경될 수 있기 때문에, 캐시는 반드시 그들이 갖고 있는 사본이 여전히 최신인지 서버를 통해 때때로 점검해야 함.
- 이러한 '신선도 검사'를 "재검사"라고 부름.
- 효과적인 재검사를 위해 HTTP는 서버로부터 전체 객체를 가져오지 않고도 콘텐츠가 여전히 신선한지 빠르게 검사할 수 있는 특별한 요청을 정의.
- 캐시는 스스로 원한다면 언제든지 사본을 재검사 가능.
    - 네트워크 대역폭은 부족하기 때문에, 대부분의 캐시는 클라이언트가 사본을 요청하였으며 그 사본이 검사를 할 필요가 있을 정도로 충분히 오래된 경우에만 재검사 진행.
- 캐시는 캐시된 사본의 재검사가 필요할 때, 원 서버에 작은 재검사 요청을 보냄.
    - 콘텐츠가 변경되지 않았다면, 서버는 아주 작은 304 Not Modified 응답을 보냄.
        - 그 사본이 여전히 유효함을 알게된 캐시는 즉각 사본이 신선하다고 임시로 다시 표시한 뒤 그 사본을 클라이언트에 제공.
          > 이를 재검사 적중(느린 적중)이라 함.
        - 이것은 순수 캐시 적중보다 느림.
            - 원 서버와 검사를 할 필요가 있기 때문.
        - 캐시 부적중보다는 빠름.
            - 서버로부터 객체 데이터를 받아올 필요가 없기 때문.
- HTTP는 캐시된 객체를 재확인하기 위한 몇 가지 도구를 제공하는데, 그 중에서 가장 많이 쓰이는 것은 `If-Modified-Since` 헤더.
    - 서버에게 보내는 GET 요청에 이 헤더를 추가하면 캐시된 시간 이후에 변경되 경우에만 사본을 보내달라는 의미.

### 7.5.2 적중률

- 캐시 적중률(캐시 적중비, 문서 적중률, 문서 적중비): 캐시가 요청을 처리하는 비율.
    - 적중률은 0에서 1까지의 값으로 되어 있지만, 퍼센트로 표현되기도 함.
        - 0%는 모든 요청이 캐시 부적중, 100%는 모든 요청이 캐시 적중.
- 캐시 관리자는 캐시 적중률이 100%에 근접하게 되는 것을 선호.
    - 실제 적중률은 다음에 달려있음.
        - 캐시가 얼마나 큰지
        - 캐시 사용자들의 관심사가 얼마나 비슷한지
        - 캐시된 데이터가 얼마나 자주 변경되거나 개인화되는지
        - 캐시가 어떻게 설정되어 있는지
- 보통 크기의 캐시라도 충분한 분량의 자주 쓰이는 문서들을 보관하여 상당히 트래픽을 줄이고 개선 가능.

> 캐시는 유용한 콘텐츠가 캐시 안에 머무르도록 보장하기 위해 노력.

### 7.5.3 바이트 적중률

- 문서들이 모두 같은 크기인 것은 아니므로 문서 적중률이 모든 것을 말해주지 않음.
- 바이트 단위 적중률: 캐시를 통해 제공된 모든 바이트의 비율을 표현.
    - 이 측정값은 트래픽이 절감된 정도를 포착.
    - 바이트 단위 적중률 100%는 모든 바이트가 캐시에서 왔으며, 어떤 트래픽도 인터넷으로 나가지 않았음을 의미.
- 문서 적중률과 바이트 단위 적중률은 둘 다 캐시 성능에 대한 유용한 지표.
- 문서 적중률
    - 얼마나 많은 웹 트랜잭션을 외부로 보내지 않았는지 보여줌.
    - 트랜잭션은 고정된 소요 시간을 포함하게 되는데, 문서 적중률을 개선하면 전체 대기시간(지연)이 줄어듬.
- 바이트 단위 적중률
    - 얼마나 많은 바이트가 인터넷으로 나가지 않았는지 보여줌.
    - 바이트 단위 적중률의 개선은 대역폭 절약을 최적화.

### 7.5.4  적중과 부적중의 구별

- HTTP는 클라이언트에게 응답이 캐시 적중이었는지 아니면 원 서버 접근인지 말해줄 수 있는 방법을 제공하지 않음.
    - 두 경우 모두 응답 코드는 응답이 본문을 갖고 있음을 의미하는 `200 OK`
- 클라이언트가 응답이 캐시에서 왔는지 알아내는 한 가지 방법은 `Date` 헤더를 이용하는 것.
    - 응답의 `Date` 헤더 값을 현재 시각과 비교하여, 응답의 생성일이 더 오래되었다면 클라이언트는 응답이 캐시된 것임을 알아낼 수 있음.
- 클라이언트가 캐시된 응답을 감지하는 또 다른 방법은, 응답이 얼마나 오래되었는지 말해주는 `Age` 헤더를 이용하는 것.

## 7.6 캐시 토폴로지

- 캐시는 한 명의 사용자에게만 할당될 수도 있고 수천 명의 사용자들 간에 공유될 수도 있음.
- 한 명에게만 할당된 캐시를 개인 전용 캐시(private cache)라고 부름.
    - 개인만을 위한 캐시이므로, 한 명의 사용자가 자주 찾는 페이지를 담음.
- 공유된 캐시를 공용 캐시(public cache)라고 부름.
    - 사용자 집단에서 자주 쓰이는 페이지를 담음.

### 7.6.1 개인 전용 캐시

- 개인 전용 캐시는 많은 에너지나 저장 공간을 필요로 하지 않으므로, 작고 저렴할 수 있음.
- 웹 브라우저는 개인 전용 캐시를 내장.
- 대부분의 브라우저는 자주 쓰이는 문서를 개인용 컴퓨터의 디스크와 메모리에 캐시해 놓고, 사용자가 캐시 사이즈와 설정을 수정할 수 있도록 허용.
    - 캐시에 어떤 것들이 들어있는지 확인하기 위해 브라우저 안을 들여다보는 것도 가능.

### 7.6.2 공용 프록시 캐시

- 공용 캐시는 캐시 프록시 서버 혹은 프록시 캐시라고 불리는 특별한 종류의 공유된 프록시 서버.
- 프록시 캐시는 로컬 캐시에서 문서를 제공하거나, 혹은 사용자의 입장에서 서버에 접근.
- 공용 캐시에는 여러 사용자가 접근하기 때문에, 불필요한 트래픽을 줄일 수 있는 더 많은 기회가 있음.
    - 자주 찾는 객체를 단 한 번만 가져와 모든 요청에 대해 공유된 사본을 제공함으로써 네트워크 트래픽을 줄임.
- 프록시 캐시는 프록시를 위한 규칙에 따르며 수동 프록시를 지정하거나 프록시 자동설정 파일을 설정함으로써 브라우저가 프록시 캐시를 사용하도록 설정 가능.
- 인터셉트 프록시를 사용함으로써 브라우저의 설정 없이 HTTP 요청이 캐시를 통하도록 강제 가능.

### 7.6.3 프록시 캐시 계층들

- 작은 캐시에서 캐시 부적중이 발생했을 때 더 큰 부모 캐시가 그 트래픽을 처리하도록 하는 계층을 만드는 방식이 합리적일 수 있음.
- 클라이언트 주위에는 작고 저렴한 캐시를 사용하고, 계층 상단에는 많은 사용자들에 의해 공유되는 문서를 유지하기 위해 더 크고 강력한 캐시를 사용.
- 캐시 계층이 깊다면 요청은 캐시의 긴 연쇄를 따라가게 되고, 프록시 연쇄가 길어질수록 각 중간 프록시는 현저한 성능 저하 발생.

### 7.6.4 캐시망, 콘텐츠 라우팅, 피어링

- 단순 캐시 계층 대신 복잡한 캐시망을 만들고, 캐시망의 프록시 캐시는 복잡한 방법으로 서로 대화하여 어떤 부모 캐시와 대화할 것인지, 요청이 캐시를 완전히 우회해서 원 서버로 바로 가도록 할 것인지에 대한 캐시 커뮤니케이션을 동적으로 결정.
- 캐시망 안에서의 콘텐츠 라우팅을 위해 설계된 캐시들이 하는 일
    1. URL에 근거하여, 부모 캐시와 원 서버 중 하나를 동적으로 선택.
    2. URL에 근거하여, 특정 부모 캐시를 동적으로 선택.
    3. 부모 캐시에게 가기 전에, 캐시된 사본을 로컬에서 찾아봄.
    4. 다른 캐시들이 그들의 캐시된 콘텐츠에 부분적으로 접근할 수 있도록 허용하되, 그들의 캐시를 통한 인터넷 트랜짓(Internet transit)은 허용하지 않음.
- 한층 더 복잡한 캐시 사이의 관계는, 서로 다른 조직들이 상호 이득을 위해 그들의 캐시를 연결하여 서로를 찾아볼 수 있도록 함.
- 형제 캐시: 선택적인 피어링을 지원하는 캐시.
- HTTP는 형제 캐시를 지원하지 않기 때문에, 사람들은 인터넷 캐시 프로토콜(`ICP`)이나 하이퍼텍스트 캐시 프로토콜(`HTCP`) 같은 프로토콜을 이용해 HTTP를 확장.

---

## 7.7 캐시 처리 단계

### 7.7.1 단계 1: 요청 받기

- 캐시는 네트워크 커넥션에서의 활동을 감지하고, 들어오는 데이터를 읽어들임.
- 고성능 캐시는 여러 개의 들어오는 커넥션들로부터 데이터를 동시에 읽어들이고 메세지 전체가 도착하기 전에 트랜잭션 처리를 시작.

### 7.7.2 단계 2: 파싱

- 캐시는 요청 메세지를 여러 부분으로 파싱하여 헤더 부분을 조작하기 쉬운 자료구조에 담음.
    - 캐싱 소프트웨어가 헤더 필드를 처리하고 조작하기 쉽게 만듬.

### 7.7.3 단계 3: 검색

- 캐시는 URL을 알아내고 그에 해당하는 로컬 사본이 있는지 검사.
    - 로컬 복사본은 메모리, 디스크, 다른 컴퓨터 등에 저장.
- 전문적인 수준의 캐시는 객체를 로컬 캐시에서 가져올 수 있는지 판단하기 위해 빠른 알고리즘 사용.
- 문서를 로컬에서 가져올 수 없다면, 캐시는 상황이나 설정에 따라서 그것을 원 서버나 부모 프록시에서 가져오거나 실패 반환.
- 캐시된 객체는 서버 응답 본문과 원 서버 응답 헤더를 포함하고 있으므로, 객체가 얼마나 오랫동안 캐시에 머무르고 있었는지를 알려주는 기록이나 자주 사용되었는지 등에 대한 몇몇 메타 데이터 포함.

### 7.7.4 단계 4: 신선도 검사

- HTTP는 캐시가 일정 기간 동안 서버 문서의 사본을 보유할 수 있도록 해줌.
- 이 기간동안, 문서는 "신선한" 것으로 간주되고 캐시는 서버와의 접촉 없이 이 문서를 제공 가능.
- 캐시된 사본을 신선도 한계를 넘을 정도로 오래 갖고 있었다면, 그 객체는 "신선하지 않은" 것으로 간주되며, 캐시는 그 문서를 제공하기 전에 문서에 어떤 변경이 있었는지 서버와 재검사를 실행해야 함.
- HTTP의 신선도 검사 규칙은 매우 복잡.

### 7.7.5 단계 5: 응답 생성

- 캐시된 응답을 원 서버에서 온 것처럼 보이게 캐시는 캐시된 서버 응답 헤더를 토대로 응답 헤더를 생성.
    - 이 기저 헤더들은 캐시에 의해 수정되고 늘어남.
- 캐시는 클라이언트에 맞게 이 헤더를 조정해야 하는 책임이 있음.
- 캐시는 캐시 신선도 정보를 삽입하며(`Cache-Control`, `Age`, `Expires` 헤더), 요청이 프록시 캐시를 거쳐갔음을 알려주기 위해 종종 `Via` 헤더를 포함.
- 캐시는 `Date` 헤더를 조정해서는 안됨.
    - `Date` 헤더는 그 객체가 원 서버에서 최초로 생겨난 일시를 표현하는 것.

### 7.7.6 단계 6: 전송

- 응답 헤더가 준비되면, 캐시는 응답을 클라이언트에게 돌려줌.
- 프록시 캐시는 클라이언트와의 커넥션을 유지할 필요가 있음.
- 고성능 캐시는 종종 로컬 저장장치와 네트워크 `I/O` 버퍼 사이에서 문서의 콘텐츠 복사를 피함으로써 데이터를 효과적으로 전송하기 위해 노력.

### 7.7.7 단계 7: 로깅

- 대부분의 캐시는 로그 파일과 캐시 사용에 대한 통계를 유지.
- 각 캐시 트랜잭션이 완료된 후, 캐시는 통계 캐시 적중과 부적중 횟수에 대한 통계를 갱신하고 로그 파일에 요청 종류, `URL` 그리고 무엇이 일어났는지를 알려주는 항목을 추가.


## 7.8 사본을 신선하게 유지하기

- 오래된 데이터를 제공하는 캐시는 불필요.
- 캐시된 데이터는 서버의 데이터와 일치할 수 있도록 관리.
- HTTP는 어떤 캐시가 사본을 갖고 있는지 서버가 기억하지 않더라도, 캐시된 사본이 서버와 충분히 일치하도록 유지할 수 있게 해주는 단순한 메커니즘 보유.

### 7.8.1 문서 만료

- HTTP는 `Cache-Control`과 `Expires`라는 특별할 헤더들을 이용해서 원 서버가 각 문서에 유효기간을 붙일 수 있게 해줌.
    - 이 헤더들은 콘텐츠가 얼마나 오랫동안 신선한 상태로 보일 수 있는지 좌우.
- 캐시 문서가 만료되기 전에, 캐시는 필요하다면 서버와의 접촉 없이 사본 제공 가능.
- 캐시된 문서가 만료되면, 캐시는 반드시 서버와 문서에 변경된 것이 있는지 검사하고 신선한 사본을 새 유효기간과 함께 얻어 와야 함.

### 7.8.2 유효기간과 나이

- `HTTP/1.0+ Expires`, `HTTP/1.1 Cache-Control: max-age` 응답 헤더를 이용해서 유효기간을 명시.
- 절대 시간은 컴퓨터의 시계가 올바르게 맞추어져 있을 것을 요구.

|           헤더           |                                                                                                          설명                                                                                                           |
| :----------------------: | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
| `Cache-Control: max-age` | `max-age` 값은 문서의 최대 나이를 정의. <br /> 최대 나이는 문서가 처음 생성된 이후부터, 제공하기엔 더 이상 신선하지 않다고 간주될 때까지 경과한 시간의 합법적인 최댓값(초 단위). <br /> `Cache-Control: max-age=484200` |
|        `Expires`         |                                        절대 유효기간을 명시. <br /> 만약 유효기간이 경과했다면, 그 문서는 더이상 신선하지 않음. <br /> `Expires: Fri, 05 Jul 2002, 05:00:00 GMT`                                        |

### 7.8.3 서버 재검사

- 캐시된 문서가 만료되었다는 것은, 그 문서가 원 서버에 현재 존재하는 것과 실제로 다르다는 것을 의미하지는 않음.
- 서버 재검사: 캐시가 원 서버에게 문서가 변경되었는지의 여부를 물어볼 필요가 있음.
    - 재검사 결과 콘텐츠가 변경되었다면, 캐시는 그 문서의 새로운 사본을 가져와 오래된 데이터 대신 저장한 뒤 클라이언트에게도 보내줌.
    - 재검사 결과 콘텐츠가 변경되지 않았다면, 캐시는 새 만료일을 포함한 새 헤더들만 가져와서 캐시 안의 헤더들을 갱신.
- 신선하지 않은 콘텐츠는 제공하지 않으면서 서버 트래픽을 절약하고 사용자 응답 시간을 개선.
- HTTP 프로토콜이 요구하는 캐시가 반환해야할 적절한 행동.
    - 충분히 신선한 캐시된 사본
    - 원 서버와 재검사되었기 때문에, 충분히 신선하다고 확신할 수 있는 캐시된 사본
    - 에러 메세지(재검사해야 하는 원 서버가 다운된 경우)
    - 경고 메세지가 부착된 캐시된 사본(부정확할 경우)

### 7.8.4 조건부 메서드와의 재검사

- HTTP의 조건부 메서드는 재검사를 효율적으로 만듬.
- HTTP는 캐시가 서버에게 "조건부 GET"이라는 요청을 보낼 수 있도록 해줌.
    - 이 요청은 서버가 갖고 있는 문서가 캐시가 갖고 있는 것과 다른 경우에만 객체 본문을 보내달라고 하는 것.
    - 신선도 검사와 객체를 받아오는 것은 하나의 조건부 GET으로 결합.
- 조건부 GET은 GET요청 메세지에 특별한 조건부 헤더를 추가함으로써 시작.
    - 웹 서버는 조건이 참인 경우에만 객체를 반환.

|            헤더             |                                                                                             설명                                                                                              |
| :-------------------------: | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
| `If-Modified-Since: <date>` |        만약 문서가 주어진 날짜 이후로 수정되었다면 요청 메서드를 처리. 캐시된 버전으로부터 콘텐츠가 변경되 경우에만 콘텐츠를 가져오기 위해 `Last-Modified` 서버 응답 헤더와 함께 사용         |
|   `If-None-Match: <tags>`   | 마지막 변경된 날짜를 맞춰보는 대신, 서버는 문서에 대한 일련번호와 같이 동작하는 특별한 태그를 제공 가능. `If-None-Match` 헤더는 캐시된 태그가 서버에 있는 문서의 태그와 다를 때만 요청을 처리 |

### 7.8.5 If-Modified-Since: 날짜 재검사

- IMS 요청으로 불리며, 서버에게 리소스가 특정 날짜 이후로 변경된 경우에만 요청한 본문을 보내달라고 함.
    - 만약 문서가 주어진 날짜 이후에 변경되었다면, 조건은 참이고 GET 요청은 평범하게 성공.
        - 새 문서가, 새로운 만료 날짜와 그 외 다른 정보들이 담긴 헤더들과 함께 캐시에게 반환.
    - 만약 문서가 주어진 날짜 이후에 변경되지 않았다면, 조건은 거짓이고 서버는 `304 Not Modified` 응답 메세지를 클라이언트에 돌려줌.
        - 효율을 위해 본문은 보내지 않음.
        - 응답은 헤더들을 포함하지만, 원래 돌려줘야할 것에서 갱신이 필요한 것만 보내줌.
- If-Modified-Since 헤더는 서버 응답 헤더의 Last-Modified 헤더와 함께 동작.
- 원 서버는 제공하는 문서에 최근 변경 일시를 붙임.
- 캐시가 캐시된 문서를 재검사 하려고 할 때, 캐시된 사본이 마지막으로 수정된 날짜가 담긴 If-Modified-Since 헤더를 포함

```shell
If-Modified-Since: <캐시된 마지막 수정일>
```

- 콘텐츠가 변경된 경우: 최근 변경 일시는 다르고 원 서버는 새 문서를 돌려줌.
- 콘텐츠가 변경되지 않은 경우: 최근 변경 일시가 같으며 `304 Not Modified` 응답을 돌려줌.

### 7.8.6 If-None-Match: 엔터티 태그 재검사

- 최근 변경 일시 재검사가 적절히 행해지기 어려운 상황
    - 일정 시간 간격으로 다시 쓰여지지만 내용 변화 없이 같은 데이터를 포함하는 경우(변경 시각은 바뀜)
    - 전 세계의 캐시들이 그 데이터를 다시 읽어들이기엔 사소한 경우
    - 갖고 있는 페이지에 대한 최근 변경 일시를 정확하게 판별할 수 없는 경우
    - 1초보다 작은 간격으로 갱신되는 문서를 제공하는 경우
- 문서의 엔터티 태그를 새로운 버전으로 표현할 수 있으며, 엔터티 태그가 변경되었다면, 캐시는 새 문서의 사본을 얻기 위해 If-None-Match 조건부 헤더 사용 가능.
- 캐시가 객체에 대한 여러 개의 사본을 갖고 있는 경우, 그 사실을 서버에게 알리기 위해 하나의 If-None-Match 헤더에 여러 개의 엔터티 태그를 포함 가능.

```shell
If-None-Match: "v2.6"
If-None-Match: "v2.4", "v2.5", "v2.6"
If-None-Match: "foobar", "A34FAC0095", "Profiles In Courage"
```

### 7.8.7 약한 검사기와 강한 검사기

- 캐시는 캐시된 버전이 서버가 갖고 있는 것에 대해 최신인지 확인하기 위해 엔터티 태그를 사용.
    - 엔터티 태그와 최근 변경 일시는 둘다 캐시 검사기.
- 서버가 모든 캐시된 사본을 무효화시키지 않고 문서를 살짝 고칠 수 있도록 허용하고 싶은 경우, `HTTP/1.1`에서는 "그 정도면 같은 것"이라고 주장할 수 있도록 해주는 "약한 검사기(weak validator)"를 지원.
- "강한 검사기(strong validator)"는 콘텐츠가 바뀔 때마다 바뀜.
- "약한 검사기(weak validator)"는 어느 정도 콘텐츠 변경을 허용하지만, 콘텐츠의 중요한 의미가 변경되면 함께 변경.

```shell
ETag: W/"v2.6"
If-None-Match: W/"v2.6"
```

## 7.9 캐시 제어

- `HTTP`에서 문서가 만료되기 전까지 얼마나 오랫동안 캐시될 수 있게 할 것인지 설정에 대한 우선순위

1. `Cache-Control: no-store` 헤더를 응답에 첨부 가능.
2. `Cache-Control: no-cache` 헤더를 응답에 첨부 가능.
3. `Cache-Control: must-revalidate` 헤더를 응답에 첨부 가능.
4. `Cache-Control: max-age` 헤더를 응답에 첨부 가능.
5. `Expires` 헤더를 응답에 첨부 가능.
6. 아무 만료 정보도 주지 않고 캐시가 스스로 체험적인(휴리스틱) 방법으로 결정하게 함.

## 7.10 캐시 제어 설정

- 웹 서버들은 캐시 제어와 만료 HTTP 헤더들을 설정하는 서로 다른 메커니즘을 제공.

### 7.10.1 아파치로 HTTP 헤더 제어하기

- 아파치 웹 서버는 HTTP 캐시 제어 헤더를 설정할 수 있는 여러 가지 메커니즘을 제공.
- 많은 것이 디폴트로는 가능하지 않게 되어 있으므로, 활성화시킬 필요가 있음.

### 7.10.2 HTTP-EQUIV를 통한 HTML 캐시 제어

- HTTP 서버 응답 헤더는 문서의 만료와 캐시 제어 정보를 돌려주기 위해 사용.
- 웹 서버는 제공할 문서에 올바른 캐시 제어 헤더들을 부여하기 위해 설정 파일들과 상호작용.
- `HTML2.0`은 `<META HTTP-EQUIV>` 태그를 정의하여 웹 서버 설정 파일과의 상호작용 없이도 쉽게 `HTML` 문서에 `HTTP` 헤더 정보 부여 가능.
- 이 선택적인 태그는 `HTML` 문서 최상단에 위치하여 문서와 연동되어야 하는 `HTTP` 헤더들을 정의.
  ```html
  <html>
    <head>
      <title>My document</title>
      <meta http-equiv="Cache-Control" content="no-cache" />
    </head>
  </html>
  ```
- 이 HTTP-EQUIV 태그는 원래 웹 서버에서 사용되도록 의도.
    - 웹 서버는 HTML에서 `<meta http-equiv>` 태그를 파싱하여 HTTP 응답에 정해진 헤더를 삽입.
- 그러나 이 기능을 지원하는 웹 서버나 프록시는 거의 없음.
    - 서버의 부하를 가중시키고, 설정값이 정적이고 HTML을 제외한 다른 타입의 파일은 지원하지 않기 때문.
- HTTP-EQUIV를 지원하는 브라우저들은 중간의 프록시 캐시와는 다른 캐시 제어 규칙을 적용할 것이기 때문에 캐시 만료에 대한 동작에 혼란을 초래할 수 있음.

> `<META HTTP-EQUIV>` 태그는 문서의 캐시 동작을 제어하는 서투른 방법.

> 문서의 캐시 제어 요청과 커뮤니케이션하는 확실한 방법은 올바르게 설정된 서버가 보내온 `HTTP` 헤더를 이용하는 것.
