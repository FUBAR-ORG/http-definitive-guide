## 캐시

-   불필요한 데이터 전송을 줄인다.
-   네트워크 병목을 줄인다.
-   원 서버에 대한 요청을 줄인다.
-   거리로 인한 지연을 줄여준다.

#

## 적중과 부적중

-   캐시 적중: 캐시에 요청이 됐을 때 사본이 있어서 처리가 됨
-   캐시 부적중: 사본이 없다면 그냥 원 서버로 전달됨

### 재검사(신선도 검사: 사본이 최신인지 확인)

-   재검사 적중: 서버 객체가 변경되지 않음을 응답(304)
-   재검사 부적중: 서버와 캐시가 다르면 컨텐츠 전체를 응답(200)
-   객체 삭제: 서버 객체가 삭제되었을 때 사본 삭제(404)

### 적중률: 캐시가 요청을 처리하는 비율

### 바이트 적중률: 캐시를 통해 제공된 바이트 비율

    큰 객체는 덜 접근되지만 그 크기 때문에 전체 트래픽에는
    더 크게 기여하므로 바이트 적중률을 선호하기도 한다.
    (트래픽의 바이트에 요금을 매기는 사람)

### 적중과 부적중의 구별

    Data 헤더 값을 현재 시각과 비교하여
    생성일이 현재 시각보다 오래되었다면 응답이 캐시된 것

#

## 캐시 포톨로지

### 전용 캐시

    많은 에너지나 저장 공간을 필요로 하지 않으므로 작고 저렴할 수 있다.
    사용자가 캐시 사이즈와 설정을 수정할 수 있고
    내용을 보기 위해 브라우저 안을 볼 수도 있다.

### 공용 프락시 캐시

    사용자 입장에서 서버에 접근한다.
    불필요한 트래픽을 줄이는 기회가 많다.

### 프락시 캐시 계층

    클라이언트 주위는 작고 저렴한 캐시,
    계층 상단에는 많이 공유되는 문서를 유지하기 위한 크고 강한 캐시

### 캐시망, 컨텐츠 라우팅, 피어링

    어떤 부모 캐시와 대화할 것인지, 바로 원 서버에 요청할 것인지 등
    동적으로 결정하게 한다.

-   URL에 근거하여 부모 캐시와 원 서버 중 하나를 동적으로 선택한다.
-   URL에 근거하여 특정 부모 캐시를 동적으로 선택한다.
-   부모 캐시에게 가기 전에 캐시된 사본을 로컬에서 찾아본다.
-   다른 캐시들이 그들의 캐시된 컨텐츠에 부분적으로 접근할 수 있도록 허용하되 그들의 캐시를 통한 인터넷 트랜짓(트래픽이 다른 네트워크로 넘어가는 것)은 허용하지 않는다.

#

## 캐시 처리 단계

1. 요청 받기
2. 파싱
3. 검색: 캐시는 로컬 복사본이 있는지 검사하고, 사본이 없다면 사본을 받아온다.(로컬에 저장한다.)
4. 신선도 검사: 변경사항을 서버에 물어본다.
5. 응답 생성
6. 발송
7. 로깅

#

## 사본 신선도 유지

### 문서 만료

    문서에 유효기간을 붙이고
    만료시 변경점을 검사하여 사본을 업데이트 한다.

### 유효기간과 나이(Expires, Cache-Control: max-age)

### 서버 재검사

-   재검사 결과 변경: 새 사본을 가져와 업데이트하고 클라이언트에게 보낸다.
-   재검사 결과 미변경: 새 만료일을 포함한 새 헤더로 캐시 안의 헤더를 갱신한다.

### 조건부 메서드와의 재검사

    서버와 캐시 각각의 문서 내용이 다른 경우에만 요청

### If-Modifided-Since(IMS): 날짜 재검사

    특정 날짜 이후로 변경된 경우에만 요청

### If-None-Match: 엔터티 태그 재검사

    엔터티 태그가 변경되었다면 새 사본을 얻기위해 조건부 헤더를 사용한다.

#### 일시 재검사가 어려운 상황

-   일정 시간 간격으로 변경되지만 같은 데이터를 포함하고 변경시각은 바뀐 경우
-   전 세계의 캐시들이 데이터를 다시 읽어들이기엔 사소한 경우
-   최근 변경 일시를 판변할 수 없는 경우
-   1초보다 작은 간격으로 갱신되는 문서는 1초의 정밀도는 충분하지 않는 경우

### 약한 검사기 강한 검사기

    약한 검사기: 약간의 변경에도 같다고 판단하게 하는 검사기

    강한 엔터티 태그 값이나
    약한 엔터티 태그 값이라도 의미가 다르면 재활용 해서는 안된다.

### 엔터티, Last-Modified

    엔터티 태그, Last-Modified 값 반환에 따라 맞는 검사기 사용
    모두 사용 가능하다면 두 가지의 재검사 정책을 모두 사용

#

## 캐시 제어

### no-cache, no-store

    캐시가 검증되지 않은 캐시된 객체로 응답하는 것을 막는다.

### Max-Age

    문서가 서버로부터 온 이후로 흐른 시간
    s-maxage는 공용 캐시에만 적용

### Expires

    시간 대신 실제 만료 날자를 명시한다.

### Must-Revalidate

    만료 정보를 엄격히 따르게 한다.

### 휴리스틱 만료

    캐시된 문서가 마지막으로 변경된 것이 상당히 예전이라면
    정적인 문서로 판단하고 캐시에 더 오래 보관한다.

    캐시된 문서가 최근에 변경되었다면
    자주 변경되는 문서로 판단하고 짧은 기간 동안만 캐시한다.

### 클라이언트 신선도 제약

    강제 재검사, 무조건 서버 요청, 리프레시

#

## 알고리즘

### 나이와 신선도 수명

-   나이: 문서를 보낸(재검사) 후 나이를 먹은 시간 총합
-   신선도 수명: 아직 신선하다고 볼 수 있는 수명

### 나이 계산

-   응답의 나이: 생성(재검사)부터 지금, 전송되는 시간을 포함한다.
-   겉보기 나이: 모든 컴퓨터가 같은 시계임을 전제, 현재 시간 - 보낸 시간
-   클록 스큐: 시계 설정 차이 => 겉보기 나이가 음수가 되는 경우 발생
-   점층적 나이 계산: 프락시나 캐시를 통과할 때마다 나이 누적
-   네트워크 지연: 전체 왕복시간을 더함

### 완전한 나이 계산 알고리즘

    문서가 우리 캐시에 도착시 나이 + 사본의 우리 캐시에 체류한 시간

### 신선도 수명 계산

    서버와 클라이언트의 제약조건에 의존한다.

#

## 캐시와 광고

### 광고 회사의 딜레마

    캐시를 쓰면 웹 서버를 살 필요가 없다.

    캐시는 원 서버가 실제 접근 횟수를 알 수 없게 숨길 수 있다.
    원 서버는 HTTP 접근을 전혀 수신하지 않게 된다.
    접근 횟수로 가격이 책정되면 문제가 된다.

### 퍼블리셔의 응답

    캐시 무력화 기법: 캐시가 광고 시청 수를 가로채지 못하게 하는 수단

    이상적으로는 컨텐츠 제공자가 트래픽을 흡수하도록 내버려두고
    캐시는 적중 횟수를 알려야 한다.

    모든 접근을 재검사하는 방법이 있는데 트랜잭션을 느리게 한다.

### 로그 마이그레이션

    서버로 요청이 가지 않게 하는 것 = 모든 적중 로그를 유지

### 적중 측정과 사용량 제한

    서버가 캐시된 문서가 정중한 횟수의 정기적인 업데이트를 캐시로부터 받는다.
    서버는 캐시가 보고하기 전까지 무저 제공 횟수, 처리시간을 제어할 수 있다.(사용량 제한)
